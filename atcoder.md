# atcoderメモ

atcoder進めていて分からなかったことなどをメモしています。

## 再帰関数について

再帰処理についてとても分かりにくかったのでメモ。

### 引数に渡した値までの連続した値を合計する関数

下はatcoderの再帰についてのコンテンツに載っている再帰の例コードを引用

```
#include <bits/stdc++.h>
using namespace std;

int sum(int n) {
  if (n == 0) {
    return 0;
  }

  // sum関数の中でsum関数を呼び出している
  int s = sum(n - 1);
  return s + n;
}

int main() {
  cout << sum(2) << endl;    // 0 + 1 + 2 = 3
  cout << sum(3) << endl;    // 0 + 1 + 2 + 3 = 6
  cout << sum(10) << endl;   // 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55
}
```

<br />

- main処理の中でsum(2)を呼び出した場合の例

<br />

int n = 2;がint sum(int n);に渡され、

int sum(2)が呼び出される。

int s = sum(n - 1);より int s = sum(2 - 1);よって int s = sum(1);となる。

int s = sum(1);　n = 2;なので

return s + n = sum(1) + 2; これが保持されている。 ->(b)

<br />

int s = sum(1);の右辺sum(1);により、n = 1;がint sum(int n);に渡され

int s = sum(n - 1);がsum(1 - 1);よって int s = sum(0);となる。

return s + n = sum(0) + 1;これが保持されている. ->(a)

<br />

int s = sum(0);の右辺sum(0);により、 n = 0;がint sum(int n);に渡され

return 0;により0が返される。 よってsum(0) = 0;

int s = sum(0) = 0;なので、int s = 0;

<br />

(a)の s + n = sum(0) + 1;にsum(0) = 0;が代入されて

return 0 + 1 = 1;が返される。これは、int  s = sum(1);のとき

返される値のことなのでint s = sum(1) = 1;である。



(b)の s + n = sum(1) + 2;にsum(1) = 1;が代入されて

return 1 + 2 = 3;が返される。

もうこれで未処理のものはないので、最終的な返される値は3となる。

<br />

以上で再帰の流れが分かった。上から下にいもづる式に関数を呼び出し、
最後に下から上に向かって順に処理が戻ってくるようなイメージになる。

<br />

## ベースケースと再帰ステップ

再帰関数を構成するもので、ベースケースと再帰ステップがある。

- ベースケースは再帰呼び出ししないで完結する処理
- 再帰ステップは再帰呼び出しをしてその結果を使って処理を連鎖する

先のコードでは下記の部分がベースケース

```
int sum(int n) {
  if (n == 0) {
    return 0;
  }
```

<br />

再帰ステップは下記のブロック

```
int s = sum(n - 1);
return s + n;
```

<br />

### AからBまでの合計を求める関数を作成する

引数にA,Bを渡してA～Bまでの連続した整数の合計を求める関数の例

関数名をsum_rangeとする(引数はA≦B)。

sum_range(2, 5);とすると、2+3+4+5の合計を計算する関数を作成する。

2, 5という2つの引数から連続した整数を計算して合計するので、

4 = 5-1, 3 =5-2,のように、Bから1ずつ引いていけば、A～Bの間の連続する整数が計算できる。

A～Bまでの合計は 2 + 3 + 4 + 5これを表すと、(aとb-1までの連続する整数+b) が合計なので、

sum_range(a, b-1) + b;で合計が計算される。あとはb-1の部分を再帰ステップで減らしていくことで

連続した整数が求まるようになる。

ここは再帰の処理の流れに慣れていないと作ることはかなり難しいと思った。

再帰に多く触れて作って慣れることが大切とのこと。

<br />

関数名を決めて引数を決めたので、まず関数は下記のように書ける。
この中に、ベースケースと再帰ステップを記載する。

```
int sum_range(int a, int b){
//ベースケース

//再帰ステップ

}
```

<br />

上記関数の中でsum_range()を繰り返し呼び出していくので、
再帰ステップの部分にsum_range()を書けばよさそうなことがわかる。

A～Bまでの連続する整数はb-1, b-2,...のようにBから１ずつ減らしていけばいいので、再帰ステップの
sum_range()の引数に(a, b-1)を渡したらよさそう。

引数a,b = (2,5)とすると、この引数から再帰ステップでa,b-1が計算されa=2, b-1=5-1=4より再帰ステップで
sum_range(2, 4) + 5となる。ここからまた最初のsum_range(2, 4)が呼ばれ、
再帰ステップの中でsum_range(2, 3) + 4となる。
この引数の値からまた最初のsum_range(2, 3)が呼ばれ、再帰ステップのでsum_range(2, 2) + 3となる。
ここで、a==bとなったらaをリターンするようにしたらよい。


以上で未処理のsum_range()が記憶領域に格納される。

sum_range(2, 4) + 5; ->(3)
sum_range(2, 3) + 4; ->(2)
sum_range(2, 2) + 3; ->(1)

最後にa == b とならないようにするには、再帰ステップのsum_range()で
sum_range(2, 2) + 3;から最初のsum_range()に(2, 2)を渡したあとに判定をして
sum_range()の処理が終わるようにすればいいので、

if(a == b) return a;

とする。これがベースケースになる。

sum_range(2, 2)の値は2となる。

ここから、

(1)のsum_range(2, 2) + 3;より2 + 3 = 5;となる。

ここで注意したいのが、再帰ステップのsum_range(2, 2) + 3 = 5;は
sum_range(2, 3)の実行結果なことを見落とさないようにする。
当たり前だけどなかなか気づかずsum(2, 3)の値がしばらく分からなかった。
(1)からsum(2, 3) = 5;なので、
(2)のsum_range(2, 3) + 4;は5 + 4 = 9;となる。

sum_range(2, 4) = 9;なので、
(3)のsum_range(2, 4) + 5;より9 + 5 = 14;となる。


以上で未処理のものはなくなったので、14が返り値となる。

<br />

<完成コードは下記>

```
int sum_range(int a, int b){

  //ベースケース
　if(a == b) {
      return a;
  }

  //再帰ステップ
  return sum_range(a, b -1) + b;

}
```




