# Visual Studio 2005を習得するためのメモ

メルカリで入手したvisual studio 2005 standard editionを使って勉強していく際のメモを

書いていきます。

なぜ2021年にvisual studio 2005を使うかというと、c++を使ったアプリを作れるようになりたい

のもそうだけど、古いthinkpad使いたいのが一番の目的かも。

古いthinkpadを使いたいけどネット接続はOSが古いので危険なので、ネットにつながない。

となると、文書作成したりコマンドプロンプトやバッチファイルの書き方を勉強するくらいしか使い道が

なさげ。

visual studioを使うことで古いthinkpadを活用でき、使い道の限られた古いwindowsを有意義に使える。

visual studio 2005はwindows2000～xpまでのOSで使えるらしいので、

windows xpのthinkpad T42にvisual studio 2005をインストールしました。

<br />

## visual studio 2005を使って勉強進める際の問題点

問題点は、2000年代前半のvisual studioなのでvisual studio2005の情報がネット上に

ほとんど存在しないこと。

僕が検索した限り16年くらい前はがっつりvisual studioの使い方など実用的な記事を作っていた人は少ないみたい。

最近の情報ならあるけど互換性の問題も大きいです。

書き方が今と違ったりするので新しいバージョンのvisual studioの情報では分からないことがあったときに躓く可能性があります。

<br />

## MSDNライブラリを活用する

cd-romからインストールしたMSDNライブラリに充実した内容のコンテンツがいっぱいあるので、

MSDNライブラリを活用するのが一番よさそうです。

チュートリアルが多くあるので、まずはチュートリアルを進めて作りつつ勉強していく方針で進めます。

<br />

## 用語など

チュートリアルを進めていくときにメモをとっていく。

### DLL

Dynamic Link Library(動的リンクライブラリ)

DLLとは、Windowsのプログラムファイルの種類のひとつ。いろいろなプログラムから利用される汎用性の高い機能が収録された、

部品化されたプログラム。拡張子は.dll

動的リンクライブラリという名前のとおり、実行時に必要なファイルを動的にリンクする。

動的リンクは実行ファイルから参照されるライブラリなどを実行時に連結する。

実行環境側でライブラリを用意する必要があるが実行ファイル本体を軽量にでき、

本体のみやライブラリのみなどといった、依存性が低いので部分的な修正や更新がやりやすい。

静的リンクの場合は、リンカは参照される関数全部をstatic link libraryから取得して実行コード内に配置

する。一方、dllの動的リンクは実行時での必要な情報だけ含めることが可能なので、メモリの節約など利点が多い。

<br />

### スタティックライブラリ

dllはプログラムの実行時に合体させるライブラリとは対照的に、

スタティックライブラリはプログラムを作成するときにプログラムと合体させるライブラリのこと。

<br />

### ビルドしたときにメッセージで出てくるマニフェストとは

ビルドしたアプリケーションのランタイム依存について書かれたドキュメントをマニフェストという.

外部ファイルか、ニーモックで書かれたアセンブリか、アプリ内に埋め込まれる。

<br />

### シンボルとは

プログラムデータベースファイル(.pdb)のことをシンボルファイルと呼ぶ。

プログラムデータベースファイルとは、デバッグ時に作成されるファイルのことで、

ソースコードをコンパイル時にソースコードからpdbファイルが作られる。

pdbファイルには、プログラムに関するデバッグ情報とプログラムの状態が保持されている。

<br />

## windows フォームコントロール

windowsのwindowの枠内に表示、機能させることができるアプリケーション

windowsフォームアプリケーション(共通言語ランタイムを対象にするGUIアプリケーション)に配置されるコンポーネントのことを

フォームコントロールという。

<br />

### CLRとは

Common Language Runtime(共通言語ランタイム)の略で、.net applicationを実行するためのバーチャルマシンのこと。

.net applicationとは、マイクロソフトが開発したアプリ開発や実行環境のこと。

CLRがマネージドコードの取得とコンパイルと実行を行う。

マネージドコードとは、実行がCLRによって管理されているコードのこと。

<br />

### マネージアセンブリとは

マネージドコードで部品化したプログラムを作成し、部品化(モジュール化)することで、他で参照して使う。

作成するプログラムごとにいちいち部品を実装するのではなく、マネージアセンブリを作っておくと他のアプリケーションから

マネージアセンブリを機能として参照して使える。

CLR(共通言語ランタイム)の環境を前提とした部品プログラムをマネージアセンブリと呼ぶ。

<br />

### プリコンパイル済みヘッダーファイルとは

ヘッダーファイルまたはヘッダーファイルに含まれるファイルの内容が変更された場合のみ

コンパイルされる機能のこと。

コンパイル時間を短くしてくれるのでビルド時間が短くなる。

すでにコンパイルが通っていて変更がなく安定しているコードについては解析の対象から除外

することで、コンパイル時間が短縮される。

<br />

### ref修飾子とは

参照渡しにできる修飾子。refという単語から参照であることがわかりやすい。

```
public ref class MyMathFuncs {//method...}
```

<br />

### gcnewとは

CLR環境で使う。参照渡し、値渡しのデータに対してマネージド型のメモリが割り当てられ、

ガベージコレクションによって自動的にメモリが解放される。

```
if (b == 0)
{
  thwow gcnew DivideByZeroException("b cannot be Zero!");
}
```

<br />

***

## COMとは

component object modelとは、マイクロソフトによる、ソフトウェアの機能を部品化して外部から呼び出して利用する仕組みのこと。

OSやプログラミング言語に依存しないので、様々な言語やOSで開発されたプログラムを連携できる。

部品化された（単体では動作しない）ソフトウェアをCOMコンポーネントと呼ぶ。

アプリケーションに組み込むことで、その機能を呼び出し、利用するような使い方をする。

<br />

### COMサーバーとは

COMをコンポーネントを使うとき、使う側であるアプリケーションソフトウェアはCOMインターフェースを介してCOMコンポーネントと

通信を行う。COMコンポーネントを提供するものがCOMサーバー。

ググっても説明が見当たらないのでこんな感じのイメージ。

<br />

### ATL(Active Template Library)とは

COM開発を簡単にするためのラッパーライブラリ。

<br /> 

### MFC(Microsoft Foundation Classes)とは

Visual C++でのWindows用のアプリ構築するときに利用するクラスライブラリ。

ATLと一緒にVisual Studioに同梱されるライブラリ。

一般的にアプリでよく使われるクラスが準備されている。

<br />

### regsvr32

windowsのコマンドで、Microsoft Register Serverの略。

dllファイルの登録やOLE（Object Linking and Embedding）コントロールの登録や解除の時に使うコマンド。

regsvr32コマンドでDLLファイルを登録したらdllファイルについての情報がOSのWindowsレジストリに追加される。

これによって、他のプログラムからレジストリ内でアクセスされ参照されるようになる。

例)サーバーオブジェクトであるTestServer.cppをdllオプションでコンパイルしサーバー(windowsレジストリ)に登録

```
> cl /LD TestServer.cpp
> regsvr32 TestServer.dll
```

<br />

### HRESULT型

HRESULT型はlong型の数値で、COMインターフェース関係の関数返り値に使われることが多い型。

BOOL型と似てるけど、大きな違いはBOOL型は返り値としてtrueかfalseしかないのに対し、

HRESULT型は0x00000000～0xFFFFFFFFまでの多くの値がつかえる。

BOOL型ではfalseの原因を取得したいときはGetLastError()を使う必要があったけど、HRESULT型だと値を見るだけで

falseの原因まで分かるようになっている。

***

<br />

### IDispatch

COMでイベント処理を行うときに使うインターフェース。

他のいろんなCOMインターフェースを呼び出すことができる。

COMサーバーの実装ファイルの中で宣言する。

<br />

### coclass

comではクラスのことをcoclassと呼ぶ。

<br />

### threading

threadクラスはスレッドを作成して制御する。優先順位の設定やステータスの取得を行う。

COMでは並列で動くthreadがdeadlockやrace conditionsにならないように制御してくれる機能を提供している。

race conditionsとは、並列動作するプロセスやスレッドが同じリソースにほぼ同時にアクセスしたときに

予定外の処理結果が起こってしまうこと。

プロセスにおけるCOMオブジェクトはApartmentと呼び、分けて考える。

SingleThreaded ApartmentとMultiThreaded Apartmentに分類される。

SingleThreaded ApartmentはSingleThreaded Apartmentのスレッドとの同期を

wondowsのメッセージキューを利用して同期する。

MultiThreaded Apartmentはwindowsのメッセージキューを使わずオブジェクト同士が

直接通信して同期を行う。

<br />

## no_namespace

no_namespaceインポート属性で、コンパイラに名前空間の生成をしないことを指定するための属性。

書式：#importタイプライブラリno_namespace
  
#importディレクティブはmicrosoft固有のもので、COMで使われていたもの。現在は使われていない?!

#importディレクティブを宣言することで、タイプライブラリのコンポーネントが持っているインターフェイスや  
CoClass が有効になる。

- タイプライブラリとは、COMコンポーネントの型情報を格納した型ライブラリで、ファイルの拡張子は.tlb

タイプライブラリは独立したファイルとして読み込むことも可能。  
ふつうは実行可能ファイルの.exeや.dllファイルのリソースに埋め込まれている。

<br />

### メッセージキューとは

windowsのアプリケーションはイベント駆動型のプログラムなので、メッセージを受け取り  
それに基づいて処理を行う。

その際のメッセージがメッセージキューに入っている。昔のosだとシステム全体で1つしかない  
メッセージキューからメッセージを取り出していて、他の処理にcpuが取られているとメッセージキュー  
からメッセージを送り出すことができなかったので、メッセージが届かないため処理も行われないので  
それがシステムの停止につながっていた。

以降、32bitアプリケーションではスレッドごとにメッセージキューを持っている仕組みとなった。

受信側が取り出すまでメッセージはキューに格納されたままで、必要なタイミングで取り出される。

<br />

### CoInitialize()とCoUninitialize()

COMサーバーでのCOMコンポーネントを利用するCOMクライアントプログラムのコンストラクタ　　
とデストラクタにそれぞれ記述する。

CoInitialize()はスレッド毎に呼ばれる。  
スレッドと1対1に対応付けされるApartmentのSingle Thread Apartment(STA)を作成するために初期化を行う関数。

```
struct A {
  A() { CoInitialize(NULL); }
  ~A() { CoUninitialize(); }
}A;
```

<br />

### tmain

mainのようなもの。tmainはc++にはなく、microsoftの拡張機能。  
tmainはコマンドライン引数argcとargvの部分について、コマンドライン引数の種類によって  
条件分岐される仕様となっている。

```
int _tmain(int argc, _TCHAR* argv[])
{
...
}
```

引数に渡される文字列がワイド文字かマルチバイト文字列かによって、tmainによってそれに対応した処理がされるよう  
内部的に切り替わるようになっている(ソースコードをユニコードと非ユニコード両対応にするための型)。

#### argcとargvとは

- argc: argument countの意味で、argvの配列数を示している。

- argv: argument vectorの意味で、コマンドライン引数に渡す配列情報を示している。

argvは文字列へのダブルポインタ変数になっている。

```
int main(int argc, char** argv)
```

例えば、コマンドラインから2つの文字列の引数を渡した場合。

"hello world" "neko"

それぞれの変数は異なるアドレスに格納される。

コマンドライン引数を2個渡したら下記のように3この文字列が格納されるようになっている。

100番地：{C:\c++\nekoProject\Debug\nekoProject.exe}  
200番地：{hello world}  
300番地：{neko}

コマンドライン引数を2個渡したのに3個格納される理由は、アプリケーションプログラムを  
実行したパスとファイル名が渡されるようになっているから。

なので、コマンドライン引数に何も渡さなくても、1つは必ず自動的に上記のようにパスとファイル名  
が渡されるようになっている。

つぎに、上記3つの文字列のアドレスをまとめて格納した下記のような配列が作られる。

{100番地, 200番地, 300番地}

この配列がポインタになっていて、それぞれのアドレス(100, 200, 300番地)を参照している。->１つめのポインタ。

さらにこの配列を参照しているのが、argv変数のポインタ。  
argvの番地を1000番地とすると、1000番地のargvから{100,200,300番地}をポンタで参照している。->2つめのポインタ。

以上のように、argvは文字列配列へのダブルポインタとなっている。

argcのほうは文字列配列の個数を管理している。

<br />

### CComPtr

COMのインターフェースポインターを管理するためのスマートポインタークラス。

下記のように宣言して使う。

```
CComPtr<IUnknown> spUnknown;
```

<br />

### IUnknown

IUnknownインターフェースはCOMの基盤的な抽象型。  
COMの仕様ではすべてのCOMオブジェクトはIUnknownインターフェイスを実装しなきゃいけないとされてて必須のもの。  
IUnknownはCOMのルートクラスで、すべてのCOMインターフェースはIUnknownから派生したもの。

<br />

### CoCreateInstance()

COMインスタンスを生成するためのメソッド。  
サンプルコード

```
CComPtr<IUnknown> spUnknown;
spUnknown.CoCreateInstance(__uuidof(COobject1));
...
```

#### __uuidof

式にはその型の型名やポインターや参照や配列やこれらの型に特化したテンプレートや、これらの型の変数を指定できる。  
引数は、アタッチされたGUIDを見つけるためにコンパイラが使用できる限り有効。  
GUIDとはglobally unique identifierの略で、uuidの別名。グローバル一意識別子。  
UUIDとはuniversally unique identifierの略。ソフトフェア上でオブジェクトを一意に識別するための識別子。

<br />

### インプロセスサーバーとアウトプロセスサーバー

インプロセスサーバーはdllファイルに実装されるサーバーのこと。  
アウトプロセスサーバーはexeファイルに実装されるサーバーのこと。  

<br />

### VTable

仮想関数の情報を持ったテーブルみたいなイメージ。  
ポインタでメソッドを使うときに、ポインタが参照する仮想関数が2種類以上とかあって、どれを使えば分からなくなるのを  
VTableを利用することで防ぎ、意図に沿った適切な仮想関数を参照してくれる仕組み。

<br />

### ストレージクラス

変数や定数のデータを格納したメモリ領域をオブジェクトと呼ぶ。  
オブジェクトが格納されたメモリ空間の種類をストレージクラスと呼ぶ。

オブジェクトはライフタイムとかデータのアクセス保護情報の違いで、異なる種類のメモリ空間に属している。  
同じメモリ空間に属す場合でも、初期値によってその初期化方法が異なる場合がある。  
それらのメモリ空間はそれぞれ異なるアクセス保護がされる。  
ストレージクラスとは、オブジェクトがそれらどのメモリ空間に属するかを指すためのもの。  

メモリ空間の種類は言語処理系に依存する。代表的なメモリ空間は下記。

- スタック領域  
言語処理系が必要に応じてメモリを確保したり解放したりするメモリ空間

- ヒープ領域  
プログラムを組む人が自由に確保したり解放の操作をしてよいメモリ空間

- データ領域  
言語処理系が使用する固定サイズのメモリ空間で、プログラムの開始時にメモリが確保され、終了時に解放される。

- テキスト領域  
命令列が格納されるメモリ空間。

- 各メモリ領域の配置のされ方  
テキスト領域とデータ領域とヒープ領域はそれぞれ順番にアドレス番号の小さい方に配置される。  
スタック領域はアドレス番号の大きい方に配置される。  
領域の拡大については、スタック領域はアドレス番号の小さい方、ヒープ領域はアドレス番号の大きい方に領域を拡大させる。  

ストレージクラスは、オブジェクトがヒープ領域、スタック領域、データ領域のどの領域に属すかで分類する。

- 自動ストレージ  
関数内で定義されたローカルスコープの変数はstatic宣言される場合を除いて  
自動ストレージ(スタック領域)に格納される。自動ストレージに配置されたデータは関数が呼ばれた時に呼び出し元に割り当てられ、  
呼び出した元に制御が戻るときに割り当てが開放される。  
再帰的に関数が呼び出されたら、ある関数のあるデータはスタック領域に複数存在することになる。

- 静的ストレージ  
グローバルスコープや名前空間スコープで宣言される変数および関数やクラス内でstatic宣言される変数は  
静的ストレージ(データ領域)に格納される。リンカはプログラムが実行を開始する前に静的ストレージに変数を格納する。

- フリーストア  
newで作成されたオブジェクトはフリーストア(ヒープ領域)に格納される。格納されたデータはdeleteでヒープ領域から削除される。

どのストレージクラスにインスタンスを格納させるかを指定できるのが、microsoft固有の仕様の_declspec。  
この機能を利用することで、指定された型のインスタンスがMicrosoftに固有のストレージクラス属性を使用して格納されることを指定できる。

ストレージクラス属性にはいろいろな種類がある。staticやexternはmicrosoft固有じゃなくc++に存在する標準の仕様なので、これら以外の  
ストレージクラス属性をmicrosoftが準備している。

<br />

## __declspec(dllexport)

dll作成の時にメソッド宣言に付ける。
dllをエクスポートして他のアプリケーションで使えるようにするために付加する修飾子。

<br />

## visual C++ /EHsc

/EHscはコンパイラに対して例外処理を有効化するためのオプション。

<br />

## visual c++ /LD

/LDオプションはDLLを作成するために必要なオプション。

visual studioのメニューでdllになるようにビルド設定してビルドすると自動的に/LDオプションでdllが作成される。

コマンドラインからビルドするときは/LDコンパイラオプションを使用し出力ファイルがdllになるようにする。

<br />

## clコマンドとは

clとはvisual C++のコンパイラのことで、visual c++に付属しているコマンドラインで

clコマンドを実行するとソースファイルを手動でコンパイルできる。

例)コンパイルする例

/LDオプションでコンパイルすることでdllを作成

```
> cl /LD test.cpp
```

<br />


## <stdexcept>ヘッダーファイル

stdexceptヘッダをインクルードすると標準的な例外処理のクラスが使えるようになる。
  
```
#include <stdexcept>
using namespace std;
```
  
std名前空間で使えるのでusing namespace stdを宣言する必要がある。
  
<br />
  
## stdafx.hヘッダーファイルとは

プリコンパイル済みヘッダーファイルのこと。
visual c++のプロジェクトのcppファイルにデフォルトで書かれている。
  
<br />

## atlbase.hヘッダーファイルとは

ATLをインクルードするためのヘッダーファイル。
  
<br />


  
  





















