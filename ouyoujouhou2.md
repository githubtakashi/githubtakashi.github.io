<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ] } }); </script> 

# 応用情報の勉強メモ|2ページ目

１ページのボリュームが増えたのでノートの２ページ目。

[1ページ目のノート](ouyoujouhou1.md)

## プログラムの基本制御構造

プログラムの基本制御構造とは、"連接(連続)、選択、繰り返し"のこと。  
手続き型のプログラムはこの3つの組み合わせからできていることが多い。

手続き型のプログラムとは、プログラムの書き方のひとつで、実行すべき命令や手続きを  
上から順に従って書いていくことで構成されているプログラムのこと。
例）c言語、perl、cobol

手続き型プログラムのメリット  
上から順に書くので記述しやすい、学習コストが低い、コードが読みやすい

連接とは、上から逐次的に実行されること。選択は条件分岐、繰り返しはループのこと。  
連接という単語が意味わからないので忘れないようにしておきたい。"つながり続くこと"という意味。

<br />

## プログラム構造

再帰(リカーシブ)、再使用可能(リユーサブル)、再配置可能(リロケータブル)などをプログラム構造とよぶ。  
プログラム構造という言葉が抽象的で分かりづらい。上記と結びつきにくいイメージ。

プログラム構造というよりも、プログラムの性質のことを言っている。

### 再帰

再帰構造のプログラムは、呼び出すごとに同じ名前の変数に別々の値が格納されるので、スタックを使う。  
一つの変数の箱に値がスタックされているイメージ。

<br />

### 再使用可能

再使用可能とは、プログラムがメインメモリに読み込まれて実行された後、そのまま再び先頭から同じように  
実行し直すことができる性質のプログラムのこと。  
プログラムをメモリから開放してしまうと、また使うときにメモリにプログラムをまたロードするので無駄となるのを防止。  

主記憶に再ロードしなくても複数のタスクから使用可能なプログラムを再使用可能なプログラムと呼ぶ。  
再使用可能なプログラムの分類として、再入可能、逐次再使用可能というプログラムに分かれる。  

再使用可能なプログラムは、再入可能で再帰的という特徴がある。

再入可能(リエントラント)とは、同時に複数のプログラムで使用可能な性質のプログラムのこと。  
逐次再使用可能とは、複数のプログラムから使用できるが、同時には使用不可能なので、待ち行列を作る性質のプログラムのこと。

再入可能な性質にするために、静的変数やグローバル変数を保持しない、自分のコードを書き換えない、  
リエントラントではないプログラムやサブルーチンを呼び出さないといった条件が必要となる。

<br />

### 再配置可能

再配置可能とは、プログラムを主記憶上のどの位置に置いても正しく実行できる性質のプログラムのこと。  
プログラム実行中に主記憶の格納位置を動的に変更できる。  
命令が参照するメモリ上の位置の指定を、その命令が置かれている現在の位置からの相対位置やプログラム先頭からの相対位置などで指定するようにしておくことで、  
プログラムをメモリのどこに置いても正常に動作する。

<br />

### プログラムのメモリ領域の確保

プログラムを格納するメモリ領域の確保の方法として、"静的割当て"と"動的割当て"がある。
静的割当てはプログラムが起動されたときに確保され、実行が終わるまでメモリが解放されない。  
動的割当は、ブロックやモジュールが起動されたときに確保され、ブロックやモジュールの処理が終わったら開放される。  
メインプログラムからサブプログラムを呼び出したらメモリが確保されサブプログラムが実行されるような動作なので動的割当てと呼ぶ。

<br />

## 逆ポーランド記法

後置記法という。コンパイルするときに、数式を機械語に変換する過程で使う、数式の内部表現のこと。  
演算子を変数の後ろに置くことから後置記法という。ポーランド記法は演算子を変数の前に置くので前置記法とよぶ。

逆ポーランド記法で1+2は、12+と表現する。

(a+b) * (c-d)を逆ポーランド記法で表すと、ab+cd-xとなる。

<br />

### 式を逆ポーランド記法で表現する手順

まずかっこの中の(A+B)に逆ポーランド記法を適用する。  
$x=(A+B) \times C$ -> $x=AB+ \times C$  
これでは逆ポーランド記法を適用していくのは、そのままでは難しいので  
AB+をPとおく。

すると、$x = P \times C$ -> $PC\times$  
ここで、$PC\times$をQとおく。

すると、$x = Q$ -> $xQ=$これが逆ポーランド記法の最終的な表現となる。ここで、置き換えたものを元に戻す。  

$xQ=$ -> $xPC\times=$ -> $xAB+C\times=$ 

<br />

### 逆ポーランド記法を式に戻す手順

逆ポーランド記法で表現された式をもとの式に戻すには、逆ポーランド記法で書かれた式の左側から演算子を探し、  
その演算子の直前の2つの変数に対して演算子が指定する計算をする。  

例)  
$XAB + C\times=$ 左から見ていくと、最初の演算子は+なので、  
A+BをPとおくと、$XPC\times=$  左から見ていくと、最初の演算子は$\times$なので、  
$P \times C$をQとおくと、$XP \times C=$より$XQ=$  最初の演算子は=なので、  
$X = Q$となる。ここで、置き換えたQ、Pを順に元に戻してくと完成。  

$X = Q$ -> $X = (P \times C)$ -> $X = ((A + B) \times C)$  
不要なかっこを外して、$(A + B) \times C$  
以上で逆ポーランド記法の式を普通の式に戻すことが完了。

<br />

## 文字列検索アルゴリズム

応用情報の試験で出題頻度は低いので軽く理解しておく程度でよい。
文字列検索アルゴリズムは、何種類かあるけど、大きなやり方としては同じで、  
検索対象の文字列の配列に対し検索文字を比較して1文字ずつ一致するかを比較する。

### ナイーブ法 | 力まかせでの検索

もとの文字列に対し検索する文字をもとの文字列の先頭(左側)から順番に比較する。
もっともシンプルなアルゴリズム。javaのメソッドに使われている。


例) 検索対象の文字列  
"あいうえおかきくけこ" に対し、検索文字が "おかき" の場合、

検索対象の文字列の左側から順に、検索文字も左側から順に比較する。  
なので、最初は"あ" と "お" を比較する。不一致なので、"い" と "お"を比較...のように行う。

### KMP法

ナイーブ法と同じ検索方法だけど、一度一致した文字を記憶しており、不要な比較をしなくて済むので、
ナイーブ法よりも処理が速い。

### BM法

ナイーブ法と同じだけど、検索対象は一番左側から、検索文字は一番右側から比較する。  
比較して不一致でも、検索対象の文字列に検索文字列が途中で含まれていたら、そこに移動して  
再度比較するため、1文字ずつの移動で比較じゃないので合理的。

例) 検索対象の文字列  
"あいうえおかきくけこ" に対し、検索文字列が "おかき" の場合、　　

"あいう" の "う" と、 "おかき" の "き" を比較する。不一致なので、検索文字の文字数である3文字分移動し、  
"えおか" の "か" と、 "おかき" の "き" を比較。不一致だが、"おか" が含まれるので、1文字分移動し、  
"おかき" と "おかき" の "き" を比較する。一致しており、ほかの文字も一致しているのでここで検索が完了となる。 

<br />

## プロセッサの高速化のための方式

プロセッサを開発するときのアプローチとして、CISCとRISCがある。  
どちらもVLSIを搭載して高速化する。

VLSI(Very Large Scale Integration):  
素子の集積度が10万〜1000万個くらい。

CISC(Complex Instruction Set Computer):  
複雑な命令をVLSIに集約して一つのチップにする。  
VLSIに搭載した命令群をマイクロプログラム(ストアドロジック)とよぶ。  
マイクロプログラム制御は、一部の基本的な命令だけを結線論理(ワイヤードロジック)で実行して、  
複雑な部分の命令はマイクロプログラムで実行する。

結線論理(ワイヤードロジック):  
演算や処理を物理的な素子や配線を組み合わせた論理回路で実行すること。

RISC(Reduced Instruction Set Computer):  
使用頻度が高い基本的で簡単な命令群だけにして、各命令の実行速度を速くさせる方式。  
結線論理を利用する。単純な命令だけで構成されプログラムの容量がCISCよりも大きくなることが多いので、  
コンパイラ最適化で効率化することが重要。

<br />

## マルチプロセッサ

命令の並行度とデータの並行度に着目したコンピュータ・アーキテクチャの分類として4種類がある。  
SISD,SIMD,MISD,MIMDの4つで、この分類方法はフリンの分類(フリンは名付けたひとの名前)と呼ばれている。

[この記事がわかりやすかった](https://basics.k-labo.work/2017/10/11/%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86/)ので参照する。

### SISD

SISDはSingle Instruction, Single Data streamの略。  
命令にもデータにも並列性がない、逐次処理をするコンピュータ。  
SISDの例は、シングルプロセッサのコンピュータ。

### SIMD

SIMDはSingle Instruction, Multiple Data streamsの略。  
文字からイメージが湧きにくい。  
命令列は一つだけど、それを複数のデータストリームに適用するコンピュータと考えるとイメージしやすい。  
画像、音声、動画などマルチメディア処理に使われることが多い。

### MISD

MISDはMultiple Instruction, Single Data streamの略。  
命令列が複数あって、それを一つのデータストリームに適用するコンピュータで、採用している実例が少ないアーキテクチャ。  
多数の機能ユニットが同じデータに対して異なる操作を同時にする。

### MIMD

MIMDはMultiple Instruction, Multiple Data streamsの略。  
複数の異なる命令と、それぞれ異なる複数のデータストリームがあって、それを複数のプロセッサがそれぞれ走らせる、同時並行処理。  
複数のSISDが同時並行で動いているイメージ。  
最近のマルチコアPCは、マルチコアによってアプリケーション単位に分散して処理している。

<br />

## 論理回路

[論理回路](https://e-words.jp/w/%E8%AB%96%E7%90%86%E5%9B%9E%E8%B7%AF.html)は記憶や論理演算をするための回路のこと。  
論理回路の記号がいつも覚えられない。覚えるくらい繰り返し見るしかない。  
NOT(否定)は論理回路の記号に○が付くことを覚えておく。  

### 加算器

加算器は2進数の和を計算する回路のことで、加算器は半加算器と全加算器で構成されている。  
半加算器は2つの2進数の足し算をする。一番最初に足し算する1番目の桁の足し算は、  
2進数の1+1=1で桁上がりしても関係ないので、2つの2進数の足し算をする。

2桁目の足し算では、1桁目の足し算で桁上がりした場合は3つの2進数を足し算する必要がある。
この3つの2進数の足し算をするのが全加算器。
そのため、2進数の足し算では、1桁目の計算用に半加算器、2桁目以降は全加算器で構成されている。

引き算、割り算、掛け算は足し算に変換できるので、加算器についての問題が出題される。  

[加算器の記事](https://www.seplus.jp/dokushuzemi/fe/fenavi/mastering_tech/digital_logic/)がとてもわかりやすいので参照。

2進数の足し算の桁上がりの結果にちょうど合致する論理演算が論理積のANDなので、桁上がりの計算にはAND回路が使われている。  
また、2進数2つの足し算の結果にちょうど合致するのが排他的論理和のXORなので、2つの2進数の足し算にはXOR回路が使われている。

<br />

### フリップフロップ

フリップフロップ回路とは、1ビットの情報を0または1として一時的に保持できる論理回路のこと。

<br />

### ハミング符号

すぐ忘れるのでしっかりと理解する。[ハミング符号について](https://emb.macnica.co.jp/tech_blog/13232/?msclkid=1b651f15ad2711ec9935e8d9bb4885c1)概念をしっかりと理解する。

例題(平成20年春)：  

>ハミング符号とは，データに冗長ビットを付加して， 1ビットの誤りを訂正できるようにしたものである。  
>ここでは，X1，X2，X3，X4の4ビットから成るデータに，3ビットの冗長ビットP3，P2，P1を>付加したハミング符号 X1X2X3P3X4P2P1 を考える。付加ビットP1，P2，P3は，それぞれ  
>X1⊕X3⊕X4⊕P1＝0  
>X1⊕X2⊕X4⊕P2＝0  
>X1⊕X2⊕X3⊕P3＝0  
>となるように決める。ここで⊕は排他的論理和を表す。  
>ハミング符号 1110011 には1ビットの誤りが存在する。誤りビットを訂正したハミング符号はどれか。
>ア：0110011　イ：1010011　ウ：1100011　エ：1110111

解説：  
ハミング符号1110011をデータビットと冗長ビットに分ける。  
ハミング符号はX1X2X3P3X4P2P1の順に並べられているので、

　X1=1，X2=1，X3=1，X4=0，
　P1=1，P2=1，P3=0

各ビットを問題中の3つの式に当てはめて誤りを検証する。  
最初、3つの式はそれぞれ排他的論理和が0の状態でデータビットに誤りが無い状態を定義している。  
なので、データビットまたは冗長ビットのいずれかに誤りが1ビット発生すると、排他的論理和が1となる。  
これを利用して3つの式の排他的論理和をそれぞれ検証する。

X1⊕X3⊕X4⊕P1＝1⊕1⊕0⊕1＝1
X1⊕X2⊕X4⊕P2＝1⊕1⊕0⊕1＝1
X1⊕X2⊕X3⊕P3＝1⊕1⊕1⊕0＝1

上記のように、存在する誤りが1ビットであり、すべての式の結果が0ではないということは、唯一すべての式に含まれている"X1"が誤りビットで、  
X1=0が正しいビットであると判断できる。

よって、訂正前のハミング符号1110011のX1を0に反転させたアの0110011が正解。

<br />

## RAID

RAIDはRedundant Arrays of Inexpensive Disksの略。  
実際使われるのはRAID0,1,5で、RAID2,3,4はあまり使われない。  

RAID0:  
書き込みたい1つのブロックのデータを、特定のサイズごとに分割し、複数のディスクに同時に書き込む
ので、処理が高速化される。高速化されるけど冗長化じゃないので、データの信頼性は高くはならない。  
1つのブロックを特定サイズに分割することをストライピングと呼ぶ。

RAID1:  
RAID1は2台のディスクに同じデータを書き込むことで、冗長化するので信頼性が高くなる。  
ただ冗長化するだけなので、データ処理の高速化はされない。

RAID5:  
RAID5はRAID0の機能にパリティ(誤り訂正補正)を持たせたもの。それぞれのディスクに他のディスクのパリティを書き込む  
ことで、データが破損したときにパリティを使って壊れたデータの復旧ができるので、データの耐障害性が高くなる。  
[RAID5についての分かりやすい記事](https://note.cman.jp/server/raid/raid5/)も参照する。

<br />

RAID2,3,4はパリティ用のディスク(冗長ディスク)を固定した方式。

RAID2:  
RAID2はパリティにECC機構を持っているので、エラーの回復が可能。  
何台かのディスクを1つのグループ単位として、1グループにつき1台のディスクをエラー検出のためのパリティ  
用にする。1台のディスクに障害が起こっても処理を続けることができ、ECC機構でデータの復旧もできる構成。

RAID3:  
RAID3はパリティ方式で、エラーの検出が可能。データをビットまたはバイト単位で分割し、  
ディスクに分散して書き込む。
何台かのディスクを1つのグループ単位として、1グループにつき1台のディスクをエラー検出のためのパリティ  
用にする。1台のディスクに障害が起こっても処理を続けることができる構成。

RAID4:  
データをブロック単位に分割してディスクに分散して書き込む。その他はRAID3と同じ機能。

<br />

## データベースの正規化

正規化とは、データベースの表(テーブル)を整えていくこと。なにも手を加えていない状態を非正規形といい、  
整えていく段階をレベルに分けていて、第一正規化、第二正規化、第三正規化(第4、第5もあるが応用情報では不要)がある。

データベースに保存されてるデータを使いやすくするために、ルールに基づいて整理および変形する。  
正規化することで、データの追加や更新や削除に伴う不整合や喪失の発生を防ぐことができる。

通常は第三正規化まで整理する。

### 第一正規化とは

テーブルの横方向に繰り返しの項目が存在する非正規形のテーブルから、繰り返し部分を取り除いていくこと。  
この繰り返しとは、表に横方向に同じ項目があることを意味している。

| 注文No. | 注文日 | 顧客名 | 商品コード | 顧客名 | 商品コード | 顧客名 | 商品コード |
| ------ | ----- | ----- | ----------- | ----- | --------- | ----- | ---------- |
| 1 | 22-04-22 | kachuo | 12345 | katsuoddayooon | 23456 | katsuo2323 | 45678 |

上記の例では、繰り返しとなっている顧客名、商品コードの部分を切り離して分けて2つの表を作る。

### 第二正規化とは

第1正規形テーブルから、部分関数従属している列を切り出したテーブルを第2正規形という。  
切り出す際は、部分関数従属している主キーとセットで切り出す。

第一正規化したテーブルに主キーが2種項目あるとすると、主キーの1項目だけに従属している主キー以外の項目を部分関数従属と呼ぶ。  
すべての種類の主キー項目(主キーが2項目あるとすると2項目の主キー)に従属している主キー以外の項目を完全関数従属と呼ぶ。  
主キーがA,Bとする。項目Cがある場合、主キー項目Aによって項目Cの値が特定できるし、主キー項目Bによって項目Cの値が特定できるといった場合を  
完全関数従属と呼ぶ。

| A | B | C | 
| --- | --- | --- |
| 1 | aa | kachuo |

主キーAの値1でCの値kachuoが特定でき、主キーBの値aaでkachuoが特定できるので完全関数従属と呼ぶ。といった感じ。


### 第三正規化とは

第2正規形のテーブルから主キー以外の列に関数従属している列を切り出して整理したテーブルを第3正規形という。  
関数従属している列をセットで切り出す。  
主キー以外のx列が、主キー以外のy列の値で特定できているとすると、x列とy列をセットで切り出し別のテーブルに分けるイメージ。  

主キー以外の列に関数従属していることを、推移的関数従属と呼ぶ。

### 参照制約とは

データベースの参照制約とは、テーブルのある列を外部キーとして定義するときに、特定の制約を設けること。４桁の数字、重複はだめなど。  
参照制約にした外部キーは、外部のテーブルで外部キーを使って値を参照する。外部キーは外部のテーブル内で外部キーの値を変更したりできない。  
そのため、参照制約という。

### DDLとDML

関係データベース言語としてSQL(Structured Query Language)がある。  
SQLはDDLとDMLで構成されている。

DDL(Data Definition Languege:データ定義言語)は、データベースの構造や概念スキーマ、外部スキーマなどを定義する  
DDLがある。

SQL-DDLを使ってスキーマや表の定義やビューの定義をする。

DML(Data Manipulation Language:データ操作言語)は、データベースにアクセスするためのデータベース言語。  
DMLには親言語方式と独立言語方式がある。親言語方式にはプログラムに直接DMLを書く埋め込み方式とサブルーチンとして作成した  
DMLを親プログラムからCALL文で呼び出すモジュール言語方式がある。

独立言語方式は会話型でコマンドを入力しながら実行をする。

親言語方式はコンパイラを利用するので、コンパイル方式で実行する。  
独立言語方式はコマンドを解釈しながら実行するので、インタプリタ方式で実行する。

親言語方式は、APIを利用している。APIは、アプリケーションからOSの各種機能を利用するためのインターフェース。  
APIはプログラムの互換性を維持する上でとっても重要。










