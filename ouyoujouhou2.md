<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ] } }); </script> 

# 応用情報の勉強メモ|2ページ目

１ページのボリュームが増えたのでノートの２ページ目。

[1ページ目のノート](ouyoujouhou1.md)

## プログラムの基本制御構造

プログラムの基本制御構造とは、"連接(連続)、選択、繰り返し"のこと。  
手続き型のプログラムはこの3つの組み合わせからできていることが多い。

手続き型のプログラムとは、プログラムの書き方のひとつで、実行すべき命令や手続きを  
上から順に従って書いていくことで構成されているプログラムのこと。
例）c言語、perl、cobol

手続き型プログラムのメリット  
上から順に書くので記述しやすい、学習コストが低い、コードが読みやすい

連接とは、上から逐次的に実行されること。選択は条件分岐、繰り返しはループのこと。  
連接という単語が意味わからないので忘れないようにしておきたい。"つながり続くこと"という意味。

<br />

## プログラム構造

再帰(リカーシブ)、再使用可能(リユーサブル)、再配置可能(リロケータブル)などをプログラム構造とよぶ。  
プログラム構造という言葉が抽象的で分かりづらい。上記と結びつきにくいイメージ。

プログラム構造というよりも、プログラムの性質のことを言っている。

### 再帰

再帰構造のプログラムは、呼び出すごとに同じ名前の変数に別々の値が格納されるので、スタックを使う。  
一つの変数の箱に値がスタックされているイメージ。

<br />

### 再使用可能

再使用可能とは、プログラムがメインメモリに読み込まれて実行された後、そのまま再び先頭から同じように  
実行し直すことができる性質のプログラムのこと。  
プログラムをメモリから開放してしまうと、また使うときにメモリにプログラムをまたロードするので無駄となるのを防止。  

主記憶に再ロードしなくても複数のタスクから使用可能なプログラムを再使用可能なプログラムと呼ぶ。  
再使用可能なプログラムの分類として、再入可能、逐次再使用可能というプログラムに分かれる。  

再使用可能なプログラムは、再入可能で再帰的という特徴がある。

再入可能(リエントラント)とは、同時に複数のプログラムで使用可能な性質のプログラムのこと。  
逐次再使用可能とは、複数のプログラムから使用できるが、同時には使用不可能なので、待ち行列を作る性質のプログラムのこと。

再入可能な性質にするために、静的変数やグローバル変数を保持しない、自分のコードを書き換えない、  
リエントラントではないプログラムやサブルーチンを呼び出さないといった条件が必要となる。

<br />

### 再配置可能

再配置可能とは、プログラムを主記憶上のどの位置に置いても正しく実行できる性質のプログラムのこと。  
プログラム実行中に主記憶の格納位置を動的に変更できる。  
命令が参照するメモリ上の位置の指定を、その命令が置かれている現在の位置からの相対位置やプログラム先頭からの相対位置などで指定するようにしておくことで、  
プログラムをメモリのどこに置いても正常に動作する。

<br />

### プログラムのメモリ領域の確保

プログラムを格納するメモリ領域の確保の方法として、"静的割当て"と"動的割当て"がある。
静的割当てはプログラムが起動されたときに確保され、実行が終わるまでメモリが解放されない。  
動的割当は、ブロックやモジュールが起動されたときに確保され、ブロックやモジュールの処理が終わったら開放される。  
メインプログラムからサブプログラムを呼び出したらメモリが確保されサブプログラムが実行されるような動作なので動的割当てと呼ぶ。

<br />

## 逆ポーランド記法

後置記法という。コンパイルするときに、数式を機械語に変換する過程で使う、数式の内部表現のこと。  
演算子を変数の後ろに置くことから後置記法という。ポーランド記法は演算子を変数の前に置くので前置記法とよぶ。

逆ポーランド記法で1+2は、12+と表現する。

(a+b) * (c-d)を逆ポーランド記法で表すと、ab+cd-xとなる。

<br />

### 式を逆ポーランド記法で表現する手順

まずかっこの中の(A+B)に逆ポーランド記法を適用する。  
$x=(A+B) \times C$ -> $x=AB+ \times C$  
これでは逆ポーランド記法を適用していくのは、そのままでは難しいので  
AB+をPとおく。

すると、$x = P \times C$ -> $PC\times$  
ここで、$PC\times$をQとおく。

すると、$x = Q$ -> $xQ=$これが逆ポーランド記法の最終的な表現となる。ここで、置き換えたものを元に戻す。  

$xQ=$ -> $xPC\times=$ -> $xAB+C\times=$ 

<br />

### 逆ポーランド記法を式に戻す手順

逆ポーランド記法で表現された式をもとの式に戻すには、逆ポーランド記法で書かれた式の左側から演算子を探し、  
その演算子の直前の2つの変数に対して演算子が指定する計算をする。  

例)  
$XAB + C\times=$ 左から見ていくと、最初の演算子は+なので、  
A+BをPとおくと、$XPC\times=$  左から見ていくと、最初の演算子は$\times$なので、  
$P \times C$をQとおくと、$XP \times C=$より$XQ=$  最初の演算子は=なので、  
$X = Q$となる。ここで、置き換えたQ、Pを順に元に戻してくと完成。  

$X = Q$ -> $X = (P \times C)$ -> $X = ((A + B) \times C)$  
不要なかっこを外して、$(A + B) \times C$  
以上で逆ポーランド記法の式を普通の式に戻すことが完了。

<br />

## 文字列検索アルゴリズム

応用情報の試験で出題頻度は低いので軽く理解しておく程度でよい。
文字列検索アルゴリズムは、何種類かあるけど、大きなやり方としては同じで、  
検索対象の文字列の配列に対し検索文字を比較して1文字ずつ一致するかを比較する。

### ナイーブ法 | 力まかせでの検索

もとの文字列に対し検索する文字をもとの文字列の先頭(左側)から順番に比較する。
もっともシンプルなアルゴリズム。javaのメソッドに使われている。


例) 検索対象の文字列  
"あいうえおかきくけこ" に対し、検索文字が "おかき" の場合、

検索対象の文字列の左側から順に、検索文字も左側から順に比較する。  
なので、最初は"あ" と "お" を比較する。不一致なので、"い" と "お"を比較...のように行う。

### KMP法

ナイーブ法と同じ検索方法だけど、一度一致した文字を記憶しており、不要な比較をしなくて済むので、
ナイーブ法よりも処理が速い。

### BM法

ナイーブ法と同じだけど、検索対象は一番左側から、検索文字は一番右側から比較する。  
比較して不一致でも、検索対象の文字列に検索文字列が途中で含まれていたら、そこに移動して  
再度比較するため、1文字ずつの移動で比較じゃないので合理的。

例) 検索対象の文字列  
"あいうえおかきくけこ" に対し、検索文字列が "おかき" の場合、　　

"あいう" の "う" と、 "おかき" の "き" を比較する。不一致なので、検索文字の文字数である3文字分移動し、  
"えおか" の "か" と、 "おかき" の "き" を比較。不一致だが、"おか" が含まれるので、1文字分移動し、  
"おかき" と "おかき" の "き" を比較する。一致しており、ほかの文字も一致しているのでここで検索が完了となる。 

<br />

## プロセッサの高速化のための方式

プロセッサを開発するときのアプローチとして、CISCとRISCがある。  
どちらもVLSIを搭載して高速化する。

VLSI(Very Large Scale Integration):  
素子の集積度が10万〜1000万個くらい。

CISC(Complex Instruction Set Computer):  
複雑な命令をVLSIに集約して一つのチップにする。  
VLSIに搭載した命令群をマイクロプログラム(ストアドロジック)とよぶ。  
マイクロプログラム制御は、一部の基本的な命令だけを結線論理(ワイヤードロジック)で実行して、  
複雑な部分の命令はマイクロプログラムで実行する。

結線論理(ワイヤードロジック):  
演算や処理を物理的な素子や配線を組み合わせた論理回路で実行すること。

RISC(Reduced Instruction Set Computer):  
使用頻度が高い基本的で簡単な命令群だけにして、各命令の実行速度を速くさせる方式。  
結線論理を利用する。単純な命令だけで構成されプログラムの容量がCISCよりも大きくなることが多いので、  
コンパイラ最適化で効率化することが重要。
