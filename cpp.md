## c++の基礎などメモ

c++の基礎などメモしていきます。

日本語ドキュメントがわかりやすい。

- [C++日本語ドキュメント](https://cpprefjp.github.io/)

<br />

### 関数のdefault宣言｜delete宣言

クラスを定義したときに下記メンバ関数が暗黙的(自動的)に定義される。

デフォルトコンストラクタ.  
コピーコンストラクタ.  
ムーブコンストラクタ.  
コピー代入演算子.  
ムーブ代入演算子.  
デストラクタ.  

何もしなくても暗黙的(自動的)に定義されるコンストラクタに対しdefault宣言またはdelete宣言することで、  
暗黙的にされてしまう定義に対して挙動を変えることができるイメージ。

default宣言、delete宣言を付与する対象(上記に挙げたコンストラクタ類)についてどんなものかを理解しておく必要がある。

暗黙定義される特殊関数を制御するために "= default"と "= delete"機能が追加された。

"= default"は暗黙定義されるコンストラクタ類を使用し、inlineやvirtualなどの修飾のみを明示的に付与したいときに使用する機能。　　
(下記サンプルコードで定義した以外のものは暗黙定義されたものが自動的に使用される)

```
class A {
public:
  //暗黙的に定義されるデストラクタにvirtualを付与しデフォルトで使用されるよう指定
  virtual ~A() = default;

  // 暗黙的に定義されるコピーコンストラクタにinlineを付与しデフォルトで使用されるよう指定
  inline A(const A&) = default;
};
```

<br />

"= delete"は暗黙定義を明示的に禁止するための機能で、コピーを禁止するクラスを定義するような場合に使用する。

```
class X {
public:
  // コピーは禁止するがムーブは許可する
  
  //コピーコンストラクタおよびコピー代入演算子を禁止
  X(const X&) = delete;
  X& operator=(const X&) = delete;

  // 特殊メンバ関数を明示的に定義またはdeleteした場合は、
  // それ以外の特殊メンバ関数は明示的に定義もしくはdefault宣言しなければ暗黙定義されない(下記)
  
  //デフォルトコンストラクタおよびムーブコンストラクタおよびムーブ代入演算子を使用する
  X(X&&) = default;
  X() = default;
  X& operator=(X&&) = default;
};

int main()
{
  X x1;
//X x2 = x1;  // コンパイルエラー。Xのコピーコンストラクタ(左辺値参照)はdelete宣言されている
  X x3 = X(); // OK : ムーブコンストラクト(右辺値参照)はできる

  X x4;
//x4 = x1;    // コンパイルエラー。Xのコピー代入演算子(左辺値参照)はdelete宣言されている

  X x5;
  x5 = X();   // OK : ムーブ代入(右辺値参照)はできる
}
```

<br />

"= delete"は特殊メンバ関数以外にも使用可能。

```
void f() = delete; // OK

int main()
{
//f(); // コンパイルエラー.関数f()はdelete宣言されているので使えない
}
```

<br />

#### コピーコンストラクタ

- コンストラクタとは.   
オブジェクトが生成される時に呼び出される、オブジェクトを初期化するためのメンバ関数。

コピーコンストラクタとは、そもそもの前提として代入の時に自動的に呼ばれるコンストラクタで、  
コンストラクタの内部で代入元のオブジェクトの値を使って、代入先のオブジェクトにコピーする(仕組み・挙動の)こと。

下記のサンプルコードではmain()関数の中でコピーコンストラクタによって暗黙的にposAの値がコピーされて. 
posBにセット(代入)される。

コピーコンストラクタを定義していない場合は自動的に標準のコピーコンストラクタが使われる。  
挙動としては、クラスのメンバ変数の値がそのままコピーされることになる。

下記サンプルの場合は、ZZZ posB = posA;によって、コピーコンストラクタのZZZ::ZZZ(int tmpx, int tmpy)　　
が呼ばれ、posBの変数xにposAの29,posBの変数yにposAの30が代入されることになる。

```
#include <stdio.h>

class ZZZ
{
public:
    int x;
    int y;

    ZZZ(int tmpx, int tmpy); // クラスZZZのコンストラクタ
};

//  コピーコンストラクタ
ZZZ::ZZZ(int tmpx, int tmpy) // <基底クラス名>::<コンストラクタ名>()
{
    x = tmpx;
    y = tmpy;
}

int main()
{
    ZZZ posA(29, 30); //  posAに対するコンストラクタ呼び出しで29,30がセットされる

    ZZZ posB = posA;    //  posBに対するコピーコンストラクタ呼び出し

    printf("posB.x:%d posB.y:%d", posB.x, posB.y); // posB.x:29 posB.y:30

    return 0;
}
```

#### コピーコンストラクタを自分で定義する理由

同じクラス内でポインタの役割を与えられたオブジェクトAがあるとし、ポインタが指し示すメモリ領域をMとする。  
すると、オブジェクトAのデータはメモリ領域Mに存在する。

この状態で他のオブジェクトBをコピーコンストラクタによってオブジェクトAのデータで初期化すると、  
オブジェクトAとオブジェクトBは同じメモリ領域Mのデータを共有していることになる。

この状態でデストラクタでどちらかのオブジェクトを削除すると、メモリ領域Mのデータが消去されるので、  
もう片方のオブジェクトのデストラクタが実行されてメモリ領域Mのデータを削除しようとした時に既に、  
メモリ領域Mにデータが存在しないので例外エラーとなる。

そのほかにも、２つのオブジェクトで共有しているデータを片方のオブジェクトが変更してしまうと、  
もう片方のオブジェクトにも予期しない影響が出てくる。

コピーコンストラクタ内の処理で新規でメモリ領域を作成しておくことで、メモリ領域を共有しないようにし、  
オブジェクトごとにメモリ領域を確保するようにしておく。すると、コピーコンストラクタを使うときにデータはコピーにより  
同じでも、格納されるメモリ領域が異なるので同じメモリ領域を共有することによる前述のような不具合を避けることができる。


```
//  コピーコンストラクタ
Neko::Neko(const Neko & neko)
{
    //  ヒープメモリを新たに確保
    nName = new char[strlen(neko.nName) + 1]();

    //  コピー元オブジェクトの猫名をコピー(コピー元のneko.nNameの値をコピー先のnNameにコピー)
    strcpy_s(nName, strlen(neko.nName) + 1, neko.nName);
}
```

<br />

##### コピーコンストラクタの定義方法

- コピーコンストラクタの書式　　

```
<クラス名>::<コンストラクタ名>(const <クラス名>& <オブジェクト名>){<コピー処理の内容>}
```

引数にconst修飾したクラスの参照型のオブジェクトを渡す。　　

言い換えると、参照しにいくクラスをconst修飾し、そのconst修飾したクラスをもとにオブジェクト. 
生成しそのオブジェクトを引数とする。

クラスをconst修飾しておくことで、参照するクラスのメンバが勝手に書き換えられないことを保証する。　　

もしコピーコンストラクタが参照するクラスのメンバが勝手に他から書き変えてしまっていると、  
それはコピーコンストラクタにとっては、予期せぬことかもしれないので期待と違う結果になってしまうかもしれない。　

そのため、コピーコンストラクタが参照するクラスをconst修飾しておき、コピーコンストラクタで参照するメンバが.  
他から勝手に書き換えられないようにしておく。

下記サンプルコードではコピーコンストラクタの定義をすることでコピーコンストラクタの挙動を明示している。　

```
class ZZZ
{
public:
    int x;
    int y;

    ZZZ(int tmpx, int tmpy);　// int型の引数を渡した場合に実行されるコピーコンストラクタ
    ZZZ(const ZZZ & pos);   // ポインタオブジェクトの引数を渡した場合に実行されるコピーコンストラクタ
};

// コンストラクタの実装内容
ZZZ::ZZZ(int tmpx, int tmpy)
{
    x = tmpx;
    y = tmpy;
}

//  コピーコンストラクタの実装内容
ZZZ::ZZZ(const ZZZ & pos)
{
    x = pos.x;
    y = pos.y;
}
```

<br />

##### コピーコンストラクタの使い方

コピーコンストラクタは次のように呼び出すことができる。

```
ZZZ posA(100, 200);  // 引数にint型引数２個を渡した時に実行されるコピーコンストラクタが呼ばれる
ZZZ posB = posA;    //  引数にオブジェクトを渡したときに実行されるコピーコンストラクタが呼ばれる
```

このサンプルコードでは、posBオブジェクトの初期化に"="演算子を使うことでコピーコンストラクタを呼び出している。  
他にも、下記サンプルコードのように()でコピーコンストラクタを呼び出すこともできる。  
引数の種類によってどのコンストラクタを呼ぶかが判断され呼ばれる。

```
ZZZ posA(100, 200);
ZZZ posB(posA);         //  （）を使ったコピーコンストラクタの呼び出し
```
<br />

#### ムーブコンストラクタ

- 右辺値. 
名前をもたない一時的なオブジェクト

- 左辺値. 
明示的に実態のある名前付きオブジェクト。

- 右辺値参照とは　　
C++11で追加された機能。

右辺値は基本的に評価された時点でデストラクタによって消されてしまう。
なので右辺値を生かしておくには右辺値への参照を持つ右辺値参照型という型で束縛する必要がある。

右辺値参照は、<参照するものの型>に<&&>を付加して宣言することで右辺値を参照する。    
例えば"int&&"はint型の右辺値を参照する右辺値参照の型名を宣言している。

右辺値参照型は右辺値への参照を持つための型のため左辺値。
右辺値参照型は左辺値なので、すぐ消されてしまう右辺値を保持することが可能になる。

```
int num = 100;      // num は左辺値

int&& ref1 = 100;   // OK。100 は右辺値。右辺値を参照している
int&& ref2 = num;   // コンパイルエラー。numは左辺値なので参照できない
int&& ref3 = ref1;  // コンパイルエラー。左辺値であるref1を参照しようとしている
```

ムーブコンストラクタはオブジェクトの内部値を新たなオブジェクトに移動または譲渡するための特殊なコンストラクタ。  
コピーコンストラクタと同様に、オブジェクトを初期化するときにムーブコンストラクタが呼び出される。

<br />

- コピーコンストラクタとの違いと使いどころ

コピーコンストラクタが値のコピーをするのに対し、ムーブコンストラクタは値自体を移動する。  
コピーコンストラクタでのコピー処理だと処理の負荷が大きい時にムーブコンストラクタを定義してコピーではなくムーブをさせる. 
ことで処理の効率化を図るために使う。

##### ムーブコンストラクタの書式

```
<クラス名>(<クラス名>&& value);
```

ムーブコンストラクタは元オブジェクトのコピーではなく移動をするため、  
元オブジェクトのメンバは移動した後にゼロ化（元オブジェクトのメンバにnullptrを代入）する必要がある。

ムーブの場合、ムーブ元になった右辺値は通常はムーブ直後にデストラクタが呼ばれてムーブ元になった右辺値は解放されてメモリ領域自体存在しなくなる。  
すると結果的に、ムーブ先の方が持っているポインタ変数が指し示す先には、もう何もないという状態になりエラーとなる(たぶん)。

この問題を解決するために、ムーブ時にムーブ元が持っているメモリ領域にnullptrを代入する。  
これによって、ムーブ先の方が持っているポインタ変数が指し示す先のメモリ領域にはnullptrが入っているのでデストラクタが呼ばれても何も起こらない。

ムーブ直後に呼び出される一時オブジェクトに対するデストラクタでは何も起こらなくなり、正しくムーブ先に受け継ぐことができる。

![IMG_0042](https://user-images.githubusercontent.com/43819429/146627624-e65c9dd1-67c6-43ad-949c-8e684012c910.jpg)

ムーブコンストラクタの仮引数は自身のクラス型の右辺値参照。constは付けない。  
ムーブ元から情報を移動させるためムーブ元には情報が残らないと考えられるので、constはつけなくても良い。

ムーブコンストラクタのサンプルコードは下記のようになる。

```
MyClass(MyClass&& value)
{

m_description = value->m_description;

value->m_description = nullptr;

}
```

#### 参考にした記事

- [C++ ムーブセマンティクスと右辺値の概念を初心者向けに](https://qiita.com/seriru13/items/e5953f88fe23e4140687)

- [右辺値参照とムーブ](https://programming-place.net/ppp/contents/modern_cpp/language/014.html#move_op)

- [ムーブコンストラクタ｜ムーブセマンティクスやコンテナ高速化との関係](https://marycore.jp/prog/cpp/move-constructor/)

- [関数のdefault／delete宣言](https://cpprefjp.github.io/lang/cpp11/defaulted_and_deleted_functions.html)

- [ムーブセマンティクスについての神記事。めっちゃ分かりやすいです](https://yohhoy.hatenablog.jp/entry/2012/12/15/120839)

---

## スマートポインタとは

まだ勉強するには早いかもしれないけどスマートポインタという機能をメモ。

C++11から追加された機能で、newしたあとにdeleteを忘れてメモリ領域が解放されないままとなってしまう  
ことを防止できる機能。詳細は下記リンクで勉強する。

[スマートポインタについての参考になるqiitaの記事](https://qiita.com/hmito/items/db3b14917120b285112f)

<br />

## 仮想継承

多重継承で異なる2つ以上の親から同じメンバ名を継承しているときに、どの親のメンバなのか判断ができなくなる問題を解決  
できるのが仮想継承。


仮想継承の例：

```
struct Base {
  virtual ~Base() {}
  virtual void method();
};

struct Derived1 : virtual Base {}; //Derived1はBaseから仮想継承
struct Derived2 : virtual Base {}; //Derived2はBaseから仮想継承
struct Derived3 : Derived1, Derived2 {}; //多重継承

Derived3 obj;

obj.method(); //仮想継承によりBase::method();が呼ばれる。
```

<br />


