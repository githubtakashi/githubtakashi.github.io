## c++の基礎などメモ

c++の基礎などメモしていきます。

日本語ドキュメントがわかりやすい。

- [C++日本語ドキュメント](https://cpprefjp.github.io/)

<br />

linux使っていてvimでc++プログラムを書いてコンパイルと実行する手順を忘れるのでメモ。  

コンパイル： 

```
$ g++ -c sample.cpp -o sample.o
```

実行ファイル作成し実行：  

```
$ g++ sample.o //a.outという実行ファイルが生成される
$ ./a.out //実行
```

<br />

### 関数のdefault宣言｜delete宣言

クラスを定義したときに下記メンバ関数が暗黙的(自動的)に定義される。

デフォルトコンストラクタ.  
コピーコンストラクタ.  
ムーブコンストラクタ.  
コピー代入演算子.  
ムーブ代入演算子.  
デストラクタ.  

何もしなくても暗黙的(自動的)に定義されるコンストラクタに対しdefault宣言またはdelete宣言することで、  
暗黙的にされてしまう定義に対して挙動を変えることができるイメージ。

default宣言、delete宣言を付与する対象(上記に挙げたコンストラクタ類)についてどんなものかを理解しておく必要がある。

暗黙定義される特殊関数を制御するために "= default"と "= delete"機能が追加された。

"= default"は暗黙定義されるコンストラクタ類を使用し、inlineやvirtualなどの修飾のみを明示的に付与したいときに使用する機能。　　
(下記サンプルコードで定義した以外のものは暗黙定義されたものが自動的に使用される)

```
class A {
public:
  //暗黙的に定義されるデストラクタにvirtualを付与しデフォルトで使用されるよう指定
  virtual ~A() = default;

  // 暗黙的に定義されるコピーコンストラクタにinlineを付与しデフォルトで使用されるよう指定
  inline A(const A&) = default;
};
```

<br />

"= delete"は暗黙定義を明示的に禁止するための機能で、コピーを禁止するクラスを定義するような場合に使用する。

```
class X {
public:
  // コピーは禁止するがムーブは許可する
  
  //コピーコンストラクタおよびコピー代入演算子を禁止
  X(const X&) = delete;
  X& operator=(const X&) = delete;

  // 特殊メンバ関数を明示的に定義またはdeleteした場合は、
  // それ以外の特殊メンバ関数は明示的に定義もしくはdefault宣言しなければ暗黙定義されない(下記)
  
  //デフォルトコンストラクタおよびムーブコンストラクタおよびムーブ代入演算子を使用する
  X(X&&) = default;
  X() = default;
  X& operator=(X&&) = default;
};

int main()
{
  X x1;
//X x2 = x1;  // コンパイルエラー。Xのコピーコンストラクタ(左辺値参照)はdelete宣言されている
  X x3 = X(); // OK : ムーブコンストラクト(右辺値参照)はできる

  X x4;
//x4 = x1;    // コンパイルエラー。Xのコピー代入演算子(左辺値参照)はdelete宣言されている

  X x5;
  x5 = X();   // OK : ムーブ代入(右辺値参照)はできる
}
```

<br />

"= delete"は特殊メンバ関数以外にも使用可能。

```
void f() = delete; // OK

int main()
{
//f(); // コンパイルエラー.関数f()はdelete宣言されているので使えない
}
```

<br />

#### コピーコンストラクタ

- コンストラクタとは.   
オブジェクトが生成される時に呼び出される、オブジェクトを初期化するためのメンバ関数。

コピーコンストラクタとは、そもそもの前提として代入の時に自動的に呼ばれるコンストラクタで、  
コンストラクタの内部で代入元のオブジェクトの値を使って、代入先のオブジェクトにコピーする(仕組み・挙動の)こと。

下記のサンプルコードではmain()関数の中でコピーコンストラクタによって暗黙的にposAの値がコピーされて. 
posBにセット(代入)される。

コピーコンストラクタを定義していない場合は自動的に標準のコピーコンストラクタが使われる。  
挙動としては、クラスのメンバ変数の値がそのままコピーされることになる。

下記サンプルの場合は、ZZZ posB = posA;によって、コピーコンストラクタのZZZ::ZZZ(int tmpx, int tmpy)　　
が呼ばれ、posBの変数xにposAの29,posBの変数yにposAの30が代入されることになる。

```
#include <stdio.h>

class ZZZ
{
public:
    int x;
    int y;

    ZZZ(int tmpx, int tmpy); // クラスZZZのコンストラクタ
};

//  コピーコンストラクタ
ZZZ::ZZZ(int tmpx, int tmpy) // <基底クラス名>::<コンストラクタ名>()
{
    x = tmpx;
    y = tmpy;
}

int main()
{
    ZZZ posA(29, 30); //  posAに対するコンストラクタ呼び出しで29,30がセットされる

    ZZZ posB = posA;    //  posBに対するコピーコンストラクタ呼び出し

    printf("posB.x:%d posB.y:%d", posB.x, posB.y); // posB.x:29 posB.y:30

    return 0;
}
```

#### コピーコンストラクタを自分で定義する理由

同じクラス内でポインタの役割を与えられたオブジェクトAがあるとし、ポインタが指し示すメモリ領域をMとする。  
すると、オブジェクトAのデータはメモリ領域Mに存在する。

この状態で他のオブジェクトBをコピーコンストラクタによってオブジェクトAのデータで初期化すると、  
オブジェクトAとオブジェクトBは同じメモリ領域Mのデータを共有していることになる。

この状態でデストラクタでどちらかのオブジェクトを削除すると、メモリ領域Mのデータが消去されるので、  
もう片方のオブジェクトのデストラクタが実行されてメモリ領域Mのデータを削除しようとした時に既に、  
メモリ領域Mにデータが存在しないので例外エラーとなる。

そのほかにも、２つのオブジェクトで共有しているデータを片方のオブジェクトが変更してしまうと、  
もう片方のオブジェクトにも予期しない影響が出てくる。

コピーコンストラクタ内の処理で新規でメモリ領域を作成しておくことで、メモリ領域を共有しないようにし、  
オブジェクトごとにメモリ領域を確保するようにしておく。すると、コピーコンストラクタを使うときにデータはコピーにより  
同じでも、格納されるメモリ領域が異なるので同じメモリ領域を共有することによる前述のような不具合を避けることができる。


```
//  コピーコンストラクタ
Neko::Neko(const Neko & neko)
{
    //  ヒープメモリを新たに確保
    nName = new char[strlen(neko.nName) + 1]();

    //  コピー元オブジェクトの猫名をコピー(コピー元のneko.nNameの値をコピー先のnNameにコピー)
    strcpy_s(nName, strlen(neko.nName) + 1, neko.nName);
}
```

<br />

##### コピーコンストラクタの定義方法

- コピーコンストラクタの書式　　

```
<クラス名>::<コンストラクタ名>(const <クラス名>& <オブジェクト名>){<コピー処理の内容>}
```

引数にconst修飾したクラスの参照型のオブジェクトを渡す。　　

言い換えると、参照しにいくクラスをconst修飾し、そのconst修飾したクラスをもとにオブジェクト. 
生成しそのオブジェクトを引数とする。

クラスをconst修飾しておくことで、参照するクラスのメンバが勝手に書き換えられないことを保証する。　　

もしコピーコンストラクタが参照するクラスのメンバが勝手に他から書き変えてしまっていると、  
それはコピーコンストラクタにとっては、予期せぬことかもしれないので期待と違う結果になってしまうかもしれない。　

そのため、コピーコンストラクタが参照するクラスをconst修飾しておき、コピーコンストラクタで参照するメンバが.  
他から勝手に書き換えられないようにしておく。

下記サンプルコードではコピーコンストラクタの定義をすることでコピーコンストラクタの挙動を明示している。　

```
class ZZZ
{
public:
    int x;
    int y;

    ZZZ(int tmpx, int tmpy);　// int型の引数を渡した場合に実行されるコピーコンストラクタ
    ZZZ(const ZZZ & pos);   // ポインタオブジェクトの引数を渡した場合に実行されるコピーコンストラクタ
};

// コンストラクタの実装内容
ZZZ::ZZZ(int tmpx, int tmpy)
{
    x = tmpx;
    y = tmpy;
}

//  コピーコンストラクタの実装内容
ZZZ::ZZZ(const ZZZ & pos)
{
    x = pos.x;
    y = pos.y;
}
```

<br />

##### コピーコンストラクタの使い方

コピーコンストラクタは次のように呼び出すことができる。

```
ZZZ posA(100, 200);  // 引数にint型引数２個を渡した時に実行されるコピーコンストラクタが呼ばれる
ZZZ posB = posA;    //  引数にオブジェクトを渡したときに実行されるコピーコンストラクタが呼ばれる
```

このサンプルコードでは、posBオブジェクトの初期化に"="演算子を使うことでコピーコンストラクタを呼び出している。  
他にも、下記サンプルコードのように()でコピーコンストラクタを呼び出すこともできる。  
引数の種類によってどのコンストラクタを呼ぶかが判断され呼ばれる。

```
ZZZ posA(100, 200);
ZZZ posB(posA);         //  （）を使ったコピーコンストラクタの呼び出し
```
<br />

#### ムーブコンストラクタ

- 右辺値. 
名前をもたない一時的なオブジェクト

- 左辺値. 
明示的に実態のある名前付きオブジェクト。

- 右辺値参照とは　　
C++11で追加された機能。

右辺値は基本的に評価された時点でデストラクタによって消されてしまう。
なので右辺値を生かしておくには右辺値への参照を持つ右辺値参照型という型で束縛する必要がある。

右辺値参照は、<参照するものの型>に<&&>を付加して宣言することで右辺値を参照する。    
例えば"int&&"はint型の右辺値を参照する右辺値参照の型名を宣言している。

右辺値参照型は右辺値への参照を持つための型のため左辺値。
右辺値参照型は左辺値なので、すぐ消されてしまう右辺値を保持することが可能になる。

```
int num = 100;      // num は左辺値

int&& ref1 = 100;   // OK。100 は右辺値。右辺値を参照している
int&& ref2 = num;   // コンパイルエラー。numは左辺値なので参照できない
int&& ref3 = ref1;  // コンパイルエラー。左辺値であるref1を参照しようとしている
```

ムーブコンストラクタはオブジェクトの内部値を新たなオブジェクトに移動または譲渡するための特殊なコンストラクタ。  
コピーコンストラクタと同様に、オブジェクトを初期化するときにムーブコンストラクタが呼び出される。

<br />

- コピーコンストラクタとの違いと使いどころ

コピーコンストラクタが値のコピーをするのに対し、ムーブコンストラクタは値自体を移動する。  
コピーコンストラクタでのコピー処理だと処理の負荷が大きい時にムーブコンストラクタを定義してコピーではなくムーブをさせる. 
ことで処理の効率化を図るために使う。

##### ムーブコンストラクタの書式

```
<クラス名>(<クラス名>&& value);
```

ムーブコンストラクタは元オブジェクトのコピーではなく移動をするため、  
元オブジェクトのメンバは移動した後にゼロ化（元オブジェクトのメンバにnullptrを代入）する必要がある。

ムーブの場合、ムーブ元になった右辺値は通常はムーブ直後にデストラクタが呼ばれてムーブ元になった右辺値は解放されてメモリ領域自体存在しなくなる。  
すると結果的に、ムーブ先の方が持っているポインタ変数が指し示す先には、もう何もないという状態になりエラーとなる(たぶん)。

この問題を解決するために、ムーブ時にムーブ元が持っているメモリ領域にnullptrを代入する。  
これによって、ムーブ先の方が持っているポインタ変数が指し示す先のメモリ領域にはnullptrが入っているのでデストラクタが呼ばれても何も起こらない。

ムーブ直後に呼び出される一時オブジェクトに対するデストラクタでは何も起こらなくなり、正しくムーブ先に受け継ぐことができる。

![IMG_0042](https://user-images.githubusercontent.com/43819429/146627624-e65c9dd1-67c6-43ad-949c-8e684012c910.jpg)

ムーブコンストラクタの仮引数は自身のクラス型の右辺値参照。constは付けない。  
ムーブ元から情報を移動させるためムーブ元には情報が残らないと考えられるので、constはつけなくても良い。

ムーブコンストラクタのサンプルコードは下記のようになる。

```
MyClass(MyClass&& value)
{

m_description = value->m_description;

value->m_description = nullptr;

}
```

#### 参考にした記事

- [C++ ムーブセマンティクスと右辺値の概念を初心者向けに](https://qiita.com/seriru13/items/e5953f88fe23e4140687)

- [右辺値参照とムーブ](https://programming-place.net/ppp/contents/modern_cpp/language/014.html#move_op)

- [ムーブコンストラクタ｜ムーブセマンティクスやコンテナ高速化との関係](https://marycore.jp/prog/cpp/move-constructor/)

- [関数のdefault／delete宣言](https://cpprefjp.github.io/lang/cpp11/defaulted_and_deleted_functions.html)

- [ムーブセマンティクスについての神記事。めっちゃ分かりやすいです](https://yohhoy.hatenablog.jp/entry/2012/12/15/120839)

---

## スマートポインタとは

まだ勉強するには早いかもしれないけどスマートポインタという機能をメモ。

C++11から追加された機能で、newしたあとにdeleteを忘れてメモリ領域が解放されないままとなってしまう  
ことを防止できる機能。詳細は下記リンクで勉強する。

[スマートポインタについての参考になるqiitaの記事](https://qiita.com/hmito/items/db3b14917120b285112f)

<br />

## 仮想継承

多重継承で異なる2つ以上の親から同じメンバ名を継承しているときに、どの親のメンバなのか判断ができなくなる問題を解決  
できるのが仮想継承。


仮想継承の例：

```
struct Base {
  virtual ~Base() {}
  virtual void method();
};

struct Derived1 : virtual Base {}; //Derived1はBaseから仮想継承
struct Derived2 : virtual Base {}; //Derived2はBaseから仮想継承
struct Derived3 : Derived1, Derived2 {}; //多重継承

Derived3 obj;

obj.method(); //仮想継承によりBase::method();が呼ばれる。
```

<br />

## 関数オブジェクト

関数オブジェクトとは、関数のようにふるまうことができるオブジェクトのこと。

クラスに関数呼び出しのための演算子を付与することで関数オブジェクトにできることが多い。  
オブジェクトを呼び出すと、オブジェクトに定義している関数が呼び出される。

c++ではoperator() という演算子を付与する。

関数オブジェクトは変数に格納したり、引数に渡したり、テンプレートやクラスのメンバとして  
渡したりと、柔軟性があるので便利。

標準ライブラリで関数オブジェクトが多く使われている。  

```
//構造体Sを定義
struct S {
  int value1_;
  int value2_;
};

//構造体Sを型として配列sを定義
vector<S> s;

//Sのvalue1_を比較するクラス
//<演算子でvalue1_の値の小さい順にソート
struct comp1 {
  bool operator()(const S& l, const S& r) const {
    return l.value1_ < r.value1_;
  }
};

//Sのvalue2_を比較するクラス
//<演算子でvalue1_の値の小さい順にソート
struct comp2 {
  bool operator()(const S& l, const S& r) const {
    return l.value2_ < r.value2_;
  }
};

comp1 c1; //c1は関数オブジェクト
comp2 c2; //c2も関数オブジェクト

sort(s.begin(), s.end, c1); //value1_の値でソート
sort(s.begin(), s.end, c2); //value2_の値でソート
```

value1_,value2_はint型なので、比較演算子"<"により、小さい値が左、大きい値が右となり、  
結果として小さい順に並ぶ。

bool operator()...のところはbool型を返す。  
正常に処理してtrue、正常に処理できない場合はfalseを返す。  
もし比較演算子の左側と右側が同じ数値だと、return l.value2_ < r.value2_;と処理できないので  
falseが返され、ソートできない。

<br />

## 可変長引数テンプレート

テンプレートで作成するクラスや関数の実引数の数が決まっていない場合、可変長引数テンプレートの書式を使うことで、  
可変長の実引数にも対応できる。

```
//クラステンプレートの書式
template <class... テンプレート仮引数パック名> [ struct | class ] クラス名;

//関数テンプレートの書式
template <class... テンプレート仮引数パック名>
  戻り値の型 関数名(テンプレート仮引数パック名... 関数仮引数パック名);
```
"..."は、仮引数の前に置くことで、複数の仮引数がまとめられ、仮引数の後ろに置くことで  
複数の仮引数を展開する機能がある。  

"テンプレート仮引数パック"には型名(typename)が入る。  
"関数仮引数パック"には型名と1セットになる関数の仮引数が入る。  

```
//...Argsはテンプレート仮引数パック。typename(型名)が複数入る
template <typename ...Args>
  //...argsは関数仮引数パック。関数に渡す引数が複数入る
  void f(Args ...args);
```

Argsには型名、argsには引数が入る。例えば、argsに{1, 2, 3.0}が入っているとすると、  
Argsにはargsである{1, 2, 3.0}に対応する型名である{int, int, double}が入っている。  

<br />

"テンプレート仮引数パック"および、"関数仮引数パック"は、"..."を前に置くことで、  
それぞれ複数の引数(パラメータ)がまとめられた状態となっていて、これをパラメータパックとよぶ。  
パラメータパックにまとまっている引数(パラメータを)展開するときは、"..."をパラメータパックの後ろに置く。  
"テンプレート仮引数パック"および、"関数仮引数パック"の後ろに"..."を書くことで、ほかの関数やクラスに中身を展開して  
渡すことができる。

classの後ろに...とひっついてセットのように見えるけど、"class"と"..."は関係ないので勘違いに注意。

詳しくは[ドキュメント](https://cpprefjp.github.io/lang/cpp11/variadic_templates.html)がわかりやすい。

[qiita](https://qiita.com/_EnumHack/items/677363eec054d70b298d)のわかりやすい記事も。

<br />

## エイリアステンプレート

intやcharなど型に対して別名をつけることが可能で、テンプレートに対しても別名をつけることが可能で、  
それをテンプレートに対する別名という意味合いでエイリアステンプレートと呼ぶ。  
エイリアステンプレートを利用することで、長い記述を自分で短い名称にできるので、可視性がよくなる。

型に別名をつける方法として、typedefとusingがある。usingを使用した型の別名定義のときだけ、  
テンプレートを使用できる。typedefを使った型の別名定義をしている場合は、テンプレートに使用できない。

エイリアステンプレートは特殊化ができない(おそらくエイリアスのため勝手にエイリアスを特殊化できないにようになっている?)。

typedef:  
例えば、intという型名をSeisuuという型名にしたいとときは、typedef int Seisuu;と書く。  
intをSeisuuという型名にするという意味。
これでSeisuu A = 3;のように、Seisuuを型名として使える。  
このように、特定の役割をもった変数などの意味をわかりやすくするために、型名を自分で名付けることができる。

using:  
typedefよりも別名をつける際の可読性をよくできるのが、using宣言。  
usingでもtypedefのように型に別名をつけることができる。  

usingを使った型の別名定義の例：  

```
using NekoCount = int;
```

int型をNekoCountという別名にしている。typedefよりも見た目上、分かりやすい。

### テンプレートの特殊化とは

テンプレートでは、仮引数の具体的な型(実引数)に対応して関数またはクラスをインスタンス化(生成)する。  
この動作を特殊化という。

テンプレートがインスタンス化されるときの具体的な型の種類で、処理を条件分岐のように分けたい  
場合に利用するのが、完全特殊化や部分特殊化。

普通のテンプレートをプライマリーテンプレートと呼ぶ(完全特殊化及び部分特殊化のテンプレートと分ける意味合い)。

完全特殊化は、テンプレート仮引数に特定の型が当てはめられたときにだけ使われる  
特別なテンプレートを定義する機能。

完全特殊化はクラステンプレートと関数テンプレートのどちらでも機能させることができる。  
部分特殊化はクラステンプレートに対して使える機能で、関数テンプレートに対しては使えない。

関数テンプレートの完全特殊化の例:

```
//通常の関数テンプレート
template <typename T>
T DoSomething(T a, T b) {
    return a + b;
}

//完全特殊化(実引数に小数が渡されると下記の関数テンプレートで特殊化が実行される)
template <>
double DoSomething<double>(double a, double b) {
    return a * b;
}

std::cout << DoSomething(3, 4) << std::endl;  // 7
std::cout << DoSomething(3.0, 4.0) << std::endl;  // 12
```

部分特殊化は、クラステンプレートの一部のテンプレート引数を確定させたり、制限したりすること。  
完全特殊化のように、対応する型を完全に決めるのではなく、ある範囲の型に対して動作を定義すること。


