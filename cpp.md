## c++の基礎などメモ

c++の基礎などメモしていきます。

日本語ドキュメントがわかりやすい。

- [C++日本語ドキュメント](https://cpprefjp.github.io/)

<br />

### 関数のdefault宣言｜delete宣言

クラスを定義したときに下記メンバ関数が暗黙的(自動的)に定義される。

デフォルトコンストラクタ.  
コピーコンストラクタ.  
ムーブコンストラクタ.  
コピー代入演算子.  
ムーブ代入演算子.  
デストラクタ.  

通常だと暗黙的に定義されるものをdefault宣言、delete宣言することで暗黙的な定義に対して挙動を変えることができるイメージ。

default宣言、delete宣言を理解する前に上記に挙げたコンストラクタ類についてどんなものかを理解しておく必要がある。

暗黙定義される特殊関数を制御するために、"= default"と "= delete"機能が追加された。

"= default"は暗黙定義されるデフォルトの挙動を使用し、inlineやvirtualなどの修飾のみを明示的に指定する目的に使用する機能。
(下記サンプルコードで定義した以外のものは暗黙定義されたものを使用する)

```
class A {
public:
  // 暗黙定義される挙動をする仮想関数のデストラクタを定義
  virtual ~A() = default;

  // 暗黙定義されるデフォルトの挙動をするインライン関数のコピーコンストラクタを定義
  inline A(const A&) = default;
};
```

<br />

"= delete"は特殊関数の暗黙定義を明示的に禁止するための機能で、コピーを禁止するクラスを定義するような場合に使用する。

```
class X {
public:
  // コピーは禁止するがムーブは許可する
  
  //コピーコンストラクタおよびコピー代入演算子を禁止
  X(const X&) = delete;
  X& operator=(const X&) = delete;

  // 特殊メンバ関数を明示的に定義またはdeleteした場合は、
  // それ以外の特殊メンバ関数は明示的に定義もしくはdefault宣言しなければ暗黙定義されない
  
  //デフォルトコンストラクタおよびムーブコンストラクタおよびムーブ代入演算子を使用する
  X(X&&) = default;
  X() = default;
  X& operator=(X&&) = default;
};

int main()
{
  X x1;
//X x2 = x1;  // コンパイルエラー。Xのコピーコンストラクタ(左辺値参照)はdelete宣言されている
  X x3 = X(); // OK : ムーブコンストラクト(右辺値参照)はできる

  X x4;
//x4 = x1;    // コンパイルエラー。Xのコピー代入演算子(左辺値参照)はdelete宣言されている

  X x5;
  x5 = X();   // OK : ムーブ代入(右辺値参照)はできる
}
```

<br />

"= delete"は特殊メンバ関数以外にも使用可能。

```
void f() = delete; // OK

int main()
{
//f(); // コンパイルエラー.関数f()はdelete宣言されているので使えない
}
```

<br />

#### コピーコンストラクタ

- コンストラクタとは.   
オブジェクトが生成される時に呼び出される、オブジェクトを初期化するためのメンバ関数。

コピーコンストラクタとは、例えば同じクラスのブループリントからオブジェクトを２個生成し、  
コンストラクタでオブジェクトを初期化したオブジェクトの値を使ってもう１個のオブジェクトにコピーする(仕組み・挙動の)こと。

このように、同じクラスのオブジェクトを使って初期化する時にコピーコンストラクタが使われる。

下記のサンプルコードではmain()関数の中でコピーコンストラクタによって暗黙的にposAの値がコピーされて. 
posBにセット(代入)される。

コピーコンストラクタを定義していない場合は自動的に定義が行われクラスのメンバ変数の値がそのままコピーされることになる。

下記サンプルの場合は、posBのコンストラクタはposAのZZZ posA(29, 30)のように定義していないので、ZZZ posB = posA;によって. 
クラスのメンバ変数であるposAの値がそのままコピーされることになる。

```
#include <stdio.h>

class ZZZ
{
public:
    int x;
    int y;

    ZZZ(int tmpx, int tmpy); // クラスZZZのコンストラクタ
};

//  引数付きのコンストラクタ
ZZZ::ZZZ(int tmpx, int tmpy) // <基底クラス名>::<コンストラクタ名>()
{
    x = tmpx;
    y = tmpy;
}

int main()
{
    ZZZ posA(29, 30); //  posAに対するコンストラクタ呼び出し

    ZZZ posB = posA;    //  posBに対するコピーコンストラクタ呼び出し

    printf("posB.x:%d posB.y:%d", posB.x, posB.y); // posB.x:29 posB.y:30

    return 0;
}
```

#### コピーコンストラクタを自分で定義する理由

同じクラス内でポインタのオブジェクトAがあるとし、ポインタが指し示すメモリ領域をMとする。  
すると、オブジェクトAのデータはメモリ領域Mに存在する。

この状態でオブジェクトBがコピーコンストラクタによってオブジェクトAのデータで初期化されると、  
オブジェクトAとオブジェクトBは同じメモリ領域Mのデータを共有していることになる。

この状態でデストラクタでどちらかのオブジェクトを削除すると、メモリ領域Mのデータが消去されるので、  
もう片方のオブジェクトのデストラクタが実行されてメモリ領域Mのデータを削除しようとした時に既に. 
メモリ領域Mにデータが存在しないので例外エラーとなる。

そのほかにも、２つのオブジェクトで共有しているデータを片方のオブジェクトが変更してしまうと、  
もう片方のオブジェクトにも予期しない影響が出てくる。

コピーコンストラクタ内の処理で新規でメモリ領域を作成しておくことで、メモリ領域を共有しないようにし、  
オブジェクトごとにメモリ領域を確保するようにしておく。すると、コピーコンストラクタを使うときにデータはコピーにより. 
同じでも格納されるメモリ領域が異なるので共有による不具合を避けることができる。

```
//  コピーコンストラクタ
Neko::Neko(const Neko & neko)
{
    //  ヒープメモリを新たに確保
    nName = new char[strlen(neko.nName) + 1]();

    //  コピー元オブジェクトの猫名をコピー
    strcpy_s(nName, strlen(neko.nName) + 1, neko.nName);
}
```

<br />

##### コピーコンストラクタの定義方法

- コピーコンストラクタの書式　　

```
<クラス名>::<コンストラクタ名>(const <クラス名>& <オブジェクト名>){<コピー処理の内容>}
```

引数にconst修飾したクラスの参照型のオブジェクトを渡す。　　

言い換えると、参照しにいくクラスをconst修飾し、そのconst修飾したクラスをもとにオブジェクトを. 
生成しそのオブジェクトを引数とする。

クラスをコンスト修飾しておくことで、参照するクラスのメンバが勝手に書き換えられないことを保証する。　　

もしコピーコンストラクタが参照するクラスのメンバが勝手に他から書き変えてしまっていると、  
それはコピーコンストラクタにとっては、予期せぬことかもしれないので期待と違う結果になってしまうかもしれない。　

そのため、コピーコンストラクタが参照するクラスをconst修飾しておき、コピーコンストラクタで参照するメンバが.  
他から勝手に書き換えられないようにしておく。

下記サンプルコードではコピーコンストラクタの定義をすることでコピーコンストラクタの挙動を明示している。　

```
class ZZZ
{
public:
    int x;
    int y;

    ZZZ(int tmpx, int tmpy);
    ZZZ(const ZZZ & pos);   //  コピーコンストラクタ
};

//  引数付きのコンストラクタ
ZZZ::ZZZ(int tmpx, int tmpy)
{
    x = tmpx;
    y = tmpy;
}

//  コピーコンストラクタの定義
ZZZ::ZZZ(const ZZZ & pos)
{
    x = pos.x;
    y = pos.y;
}
```

<br />

##### コピーコンストラクタの使い方

コピーコンストラクタは次のように呼び出すことができる。

```
ZZZ posA(100, 200);
ZZZ posB = posA;    //  コピーコンストラクタの呼び出し
```

このサンプルコードでは、posBオブジェクトの初期化に"="演算子を使うことでコピーコンストラクタを呼び出している。  
他にも、下記サンプルコードのように()でコピーコンストラクタを呼び出すこともできる。

```
ZZZ posA(100, 200);
ZZZ posB(posA);         //  （）を使ったコピーコンストラクタの呼び出し
```
<br />

#### ムーブコンストラクタ

- 右辺値. 
名前をもたない一時的なオブジェクト

- 左辺値. 
明示的に実態のある名前付きオブジェクト。

- 右辺値参照とは　　
C++11で追加された機能。

右辺値は基本的に評価された時点でデストラクタによって消失されてしまう。
なので右辺値を生かしておくには右辺値への参照を持つ右辺値参照型という型で束縛する必要がある。

右辺値参照は、<参照するものの型>に<&&>を付加して宣言することで右辺値を参照する。    
例えば"int&&"はint型の右辺値を参照する右辺値参照の型名を宣言している。

右辺値参照型は右辺値への参照を持つための型のため左辺値。
右辺値参照型は左辺値なので、すぐ消されてしまう右辺値を保持することが可能になる。

```
int num = 100;      // num は左辺値

int&& ref1 = 100;   // OK。100 は右辺値。右辺値を参照している
int&& ref2 = num;   // コンパイルエラー。numは左辺値なので参照できない
int&& ref3 = ref1;  // コンパイルエラー。左辺値であるref1を参照しようとしている
```

ムーブコンストラクタはオブジェクトの内部値を新たなオブジェクトに移動または譲渡するための特殊なコンストラクタ。  
コピーコンストラクタと同様に、オブジェクトを初期化するときにムーブコンストラクタが呼び出される。

<br />

- コピーコンストラクタとの違いと使いどころ

コピーコンストラクタが内部表現のコピーをするのに対し、ムーブコンストラクタは内部表現の移動をする。  
コピーコンストラクタでのコピー処理だと処理の負荷が大きい時にムーブコンストラクタを定義してコピーではなくムーブをさせる. 
ことで処理の効率化を図るために使う。

##### ムーブコンストラクタの書式

```
<クラス名>(<クラス名>&& value);
```

ムーブコンストラクタは元オブジェクトのコピーではなく移動をするため、  
元オブジェクトのメンバは移動した後にゼロ化（元オブジェクトのメンバにnullptrを代入）する必要がある。

ムーブの場合、ムーブ元になった右辺値は通常はムーブ直後にデストラクタが呼ばれてムーブ元になった右辺値は解放されてメモリ領域自体存在しなくなる。  
すると結果的に、ムーブ先の方が持っているポインタ変数が指し示す先には、もう何もないという状態になる。

この問題を解決するために、ムーブ時にムーブ元が持っているメモリ領域にnullptrを代入する。  
これによって、ムーブ先の方が持っているポインタ変数が指し示す先のメモリ領域にはnullptrが入っているのでデストラクタが呼ばれても何も起こらない。

ムーブ直後に呼び出される一時オブジェクトに対するデストラクタでは何も起こらなくなり、正しくムーブ先に受け継ぐことができる。

![IMG_0042](https://user-images.githubusercontent.com/43819429/146627624-e65c9dd1-67c6-43ad-949c-8e684012c910.jpg)

ムーブコンストラクタの仮引数は自身のクラス型の右辺値参照。constは付けない。  
ムーブ元から情報を移動させるためムーブ元には情報が残らないと考えられるので、constはつけなくても良い。

ムーブコンストラクタのサンプルコードは下記のようになる。

```
MyClass(MyClass&& value)
{

m_description = value->m_description;

value->m_description = nullptr;

}
```

#### 参考にした記事

- [C++ ムーブセマンティクスと右辺値の概念を初心者向けに](https://qiita.com/seriru13/items/e5953f88fe23e4140687)

- [右辺値参照とムーブ](https://programming-place.net/ppp/contents/modern_cpp/language/014.html#move_op)

- [ムーブコンストラクタ｜ムーブセマンティクスやコンテナ高速化との関係](https://marycore.jp/prog/cpp/move-constructor/)

- [関数のdefault／delete宣言](https://cpprefjp.github.io/lang/cpp11/defaulted_and_deleted_functions.html)
