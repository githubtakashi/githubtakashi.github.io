## 応用情報の過去問用ノート

このページでは過去問の苦手な部分や覚えておきたいことについて書いていく。

### マージソートの午後問題｜応用情報2021年版問題集73ページ

マージソートのプログラムについての問題が3回同じ問題をしたにもかかわらず全然分からずというレベルでわからないので、  
苦手すぎる。そのため、理解を補完するためにこのノートを作成した。

苦手ということは、問題を解くために必要な何かしらの前提とする知識が不足していると考えられるので、そこをまずは抽出。

応用情報2021年版の問題集の73ページに掲載されている問題。

データ構造がリストである数値データをマージソートのプログラムで昇り順に並び変えるという問題。

リストは、個々の要素とポインタが１つのセットになっていて、ひとつひとつの要素が繋がったもの。 
数値データはvalueと呼び、次の要素のアドレスを示すポインタをnextと呼ぶ。

マージソートを実現するための方法として、2つのプログラムを実行する。

リストを約半分になるように分割し、分割した2つのリストの先頭から順に2つずつ要素の大きさを比較し、小さい順に並べていく。

リストを分割する関数をdivideと呼ぶ。divideの引数にはlistというリストの先頭を指すポインタを渡す。  
すると、divideは実行結果として、リストを2つに分割し、2つ目のリストの先頭のポインタを戻り値として返す。

#### 関数divide

問題文にも載っているように、リストを分割するために、変数a、bを用意し、それぞれポインタを格納し、変数aのポインタを1つ進めるごとに  
変数bのポインタを2つずつ進める。変数bのポインタがリストの一番最後の要素に達するまで移動を繰り返すと、変数aのポインタは  
リストのほぼ中央の要素を指すという性質を利用してリストを分割する。

ポインタを格納する変数2つ準備する。この変数をa、bとする。
最初の設問は、下記のdivide関数のア、イ、ウに入る字句を答える問題。

```
function divide(list)
  a <- list
  b <- a->next
  if (bがnullと等しくない)
    b <- b->next
  endif
  while( ア )
    a <- a->next
    b <- b->next
    if(bがnullと等しくない)
      イ
    endif
  endwhile
  
  p <- a->next
  ウ <- NULL
  retuen p
endfunction
```

プログラムの流れ：  
変数aにlistポインタを格納し、変数bに変数aよりも1つ後ろのポインタを格納。

この初期化によって、変数aにはリストの先頭を指すポインタが格納され、変数bにはリストの2番目の要素を指すポインタが格納される。  
さらに、もしbがnullでないならば、リストの要素はまだ最後の要素ではないので、変数bに2番目+1の要素を指すポインタを格納する。

上記のように、bにリストの3番目の要素のポインタを格納するときに、bがnullでないかを確認することで、  
リストの要素が全部で2個で少ない場合にもリストの分割に対応できるようにしている。

上記までが変数a、bの初期化の処理。

<br />

次はwhileの中身が穴埋めになっているブロック。  

条件アの間に、whileブロックの中身を実行する。  
ここで考えられるのが、whileのループを利用して、変数aと変数bのポインタをそれぞれ移動して、  
変数bに格納しているポインタがリストの最後の要素になるまで繰り返すことである。

変数bに格納しているポインタがリストの最後の要素かどうかの判断は、変数bに格納したポインタがnullであるかどうかである。

もしポインタが指すアドレスがnullの場合は、そのポインタが指す要素が最後の要素となるので、アの解答は"bがnullと等しくない"となる。

変数aにaの次の要素を指すポインタを格納する。  
変数bにbの次の要素を指すポインタを格納する。  
条件アがtrueの間、上記の2つが実行される。  
条件アがtrueで最初に実行されるとき、変数aはリストの最初の要素を指すポインタが格納されている。  
そこから変数aのポインタの位置を1つ進める。  

また、変数bは初期化のときにリストの2番目または3番目を指すポインタが格納されている。  
そこから変数bのポインタの位置を1つ進める。

そしてもしbがnullではない場合は、要素の最後ではないので、イを実行する。

ここで考えられるのが、リストの分割のために変数aのポインタを１つ進めるごとに変数bのポインタを2つ進めるので、  
イは変数bのポインタをもう1つ進めるという処理。そのため、イの解答は、"b <- b->next"となる。

上記までの処理で、変数bに格納したポインタが最後尾の要素を指している。

次に、変数pを新たに宣言し、pに、変数aに格納したポインタの次の要素を指すポインタを格納している。  
変数bに格納したポインタが最後尾を指している時点では、変数aに格納したポインタは2つに分割したリストのうち、  
1つ目のリストの最後尾を指している。ここで、関数divideについての冒頭の説明のように、関数divideの戻り値は  
分割したリストの2つ目のリストの先頭を指すポインタを戻り値とすることになっているので、変数pを新たに宣言し、  
pに、変数aに格納したポインタの次の要素を指すポインタを格納している。

次に、ウにnullを格納している。もともとのリストの最後尾はnullが入っていて分割後の2つ目のリストの最後尾も同じもの  
なので特に何もする必要はないが、変数aに格納されているポインタは1つ目のリストの最後尾を指している。  
ここで、変数aに格納しているポインタの次が2つ目のリストの先頭を指すポインタであり、このポインタをnullにすることで  
1つ目のリストの最終要素となり、実質、リストの分割になる。このため、解答は、nullにするのは、"a->next"となる。

ポインタと変数とプログラムが出てくる。ポインタや変数の種類の違いが頭の中で整理できていないので、  
それが何を意味しているかを問題を解くときに書いてある程度明確にしておく。

プログラムの中で変数に代入する操作が多いので、そこで何をやっているかが分からなくなってくる。  
なので、まずはプログラムが何をしようとしているかを理解することが大切。

細部に囚われすぎて何をやっているかが分からなくなっている気がするので、そのプログラムの目的と、ブロック単位での  
その処理で何を目的としているかを、図に書くなりして理解しようと努めるほうがよいと今思えば感じた。

そこが理解できないと、プログラムが理解できるはずがないので、まずはそのプログラムがやろうとしていることを  
理解すること。

そして変数やポインタが意味することを理解、つまりプログラムの中身を詳しく追っていく。この時も、図に書いて手を動かしつつ  
進める。
